<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>LNbits Table Town - Interactive Database Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Cache busting - ensure fresh load
        console.log('Page loaded at:', new Date().toISOString());
        
        // Debug: Check initial state
        window.addEventListener('load', () => {
            console.log('Page fully loaded');
            const schemaContainer = document.getElementById('schemaContainer');
            const apiDiffTab = document.getElementById('apiDiffTab');
            console.log('Schema container:', schemaContainer);
            console.log('Schema container display:', schemaContainer.style.display);
            console.log('API Diff tab:', apiDiffTab);
            console.log('API Diff tab display:', apiDiffTab.style.display);
            console.log('Schema container children:', schemaContainer.children.length);
            console.log('API Diff tab children:', apiDiffTab.children.length);
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
            height: 100vh;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
        }

        .header {
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            border-bottom: 1px solid #333;
            height: 180px;
            overflow: hidden;
        }
        
        .header-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .header-left h1 {
            color: #e0e0e0;
            font-size: 1.8rem;
            margin: 0;
        }
        
        .header-subtitle {
            margin-top: 0.5rem;
        }
        
        .header-subtitle p {
            color: #999;
            font-size: 0.85rem;
            margin: 0.2rem 0;
            line-height: 1.3;
        }
        
        .subtitle-note {
            color: #777 !important;
            font-size: 0.75rem !important;
            font-style: italic;
        }
        
        .header-right .tabs {
            margin: 0;
        }


        /* Tabs */
        .tabs { display: flex; gap: 0.5rem; margin-top: 0.75rem; flex-wrap: wrap; }
        .tab-btn { padding: 0.45rem 0.9rem; border: 2px solid #444; background: #1a1a1a; color: #e0e0e0; border-radius: 18px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s ease; }
        .tab-btn.active { border-color: #ffffff; background: #2a2a2a; }

        .controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            align-items: center;
            position: relative;
            z-index: 1001;
        }

        .search-container {
            position: relative;
            display: inline-block;
            z-index: 1001;
            margin: 0.25rem 0;
        }

        .search-container::before {
            content: '';
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            border: 2px solid #888;
            border-radius: 50%;
            z-index: 1;
        }

        .search-container::after {
            content: '';
            position: absolute;
            left: 22px;
            top: 50%;
            transform: translateY(-50%) rotate(45deg);
            width: 2px;
            height: 6px;
            background: #888;
            z-index: 1;
        }

        .search-box {
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            border: 2px solid #444;
            border-radius: 25px;
            font-size: 0.9rem;
            min-width: 200px;
            background: #1a1a1a;
            color: #e0e0e0;
            transition: border-color 0.3s;
            position: relative;
            z-index: 1002;
        }

        .search-box:focus {
            outline: none;
            border-color: #ffffff;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: #666;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }

        .search-clear:hover {
            background: #888;
        }

        .category-bubble {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }

        .credits {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.9rem;
            color: #888;
        }

        .credits a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.3s;
        }

        .credits a:hover {
            color: #ffffff;
        }

        .filter-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .analysis-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.5rem;
        }

        .filter-btn {
            padding: 0.5rem 1rem;
            border: 2px solid #444;
            background: #1a1a1a;
            color: #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .filter-btn:hover {
            border-color: #667eea;
            background: #2a2a2a;
        }

        .filter-btn.active {
            background: #2a2a2a;
            color: #ffffff;
            border-width: 3px;
            border-color: #ffffff;
        }

        .analysis-btn {
            padding: 0.5rem 1rem;
            border: 2px solid #667eea;
            background: #1a1a1a;
            color: #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .analysis-btn:hover {
            border-color: #4CAF50;
            background: #2a2a2a;
            color: #4CAF50;
        }

        .analysis-btn.active {
            background: #4CAF50;
            color: #ffffff;
            border-color: #4CAF50;
        }


        .main-container {
            margin-top: 180px;
            position: relative;
            padding-bottom: 0;
            box-sizing: border-box;
            height: calc(100vh - 180px);
            overflow: hidden;
        }

        .schema-container {
            width: 100%;
            background: #1a1a1a;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
            padding-bottom: 50px;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.95);
            padding: 1rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            font-size: 0.8rem;
            z-index: 100;
            border: 1px solid #444;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        
        
        .constraint-explanations,
        .datatype-explanations,
        .field-examples {
            margin-bottom: 1rem;
        }
        
        .constraint-item,
        .datatype-item,
        .example-item {
            margin-bottom: 0.25rem;
            color: #ccc;
        }
        
        .constraint-item strong,
        .datatype-item strong,
        .example-item strong {
            color: #fff;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .tooltip h3 {
            color: #4CAF50;
            margin-bottom: 0.5rem;
        }

        .tooltip p {
            margin-bottom: 0.3rem;
        }

        .tooltip .technical {
            color: #FFC107;
        }

        .tooltip .user-friendly {
            color: #81C784;
        }

        .tooltip .category {
            color: #2196F3;
            font-weight: bold;
        }

        .tooltip .fields-section {
            margin: 0.5rem 0;
        }

        .tooltip .fields-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            margin-top: 0.3rem;
        }

        .tooltip .field {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.8rem;
            font-family: monospace;
        }

        .tooltip .field-more {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.8rem;
            font-style: italic;
        }

        .tooltip a {
            color: #4CAF50 !important;
            text-decoration: none;
        }

        .tooltip a:hover {
            text-decoration: underline;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }
        
        .legend-explanations {
            position: absolute;
            bottom: 60px;
            right: 20px;
            width: 450px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #444;
            border-radius: 12px;
            padding: 20px;
            color: #ffffff;
            font-size: 13px;
            z-index: 1000;
            max-height: 70vh;
            overflow-y: auto;
            display: none;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
        }
        
        .legend-explanations h4 {
            margin: 0 0 10px 0;
            color: #00ff00;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            margin-bottom: 8px;
            align-items: flex-start;
        }
        
        .legend-abbrev {
            background: #333;
            color: #00ff00;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            margin-right: 8px;
            min-width: 30px;
            text-align: center;
            font-size: 10px;
        }
        
        .legend-explanations small {
            color: #aaa;
            font-size: 10px;
            font-style: italic;
            display: block;
            margin-top: 2px;
        }
        
        .legend-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #1a1a1a;
            color: #ffffff;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            z-index: 1001;
            font-size: 12px;
            font-weight: normal;
            display: block;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            transition: all 0.2s ease;
        }
        
        .legend-toggle:hover {
            background: #2a2a2a;
            border-color: #444;
        }
        
        .legend-toggle::before {
            content: "⚙";
            margin-right: 4px;
            color: #ffffff;
        }

        /* Dependency Info Modal (like legend) */
        .dependency-info-modal {
            position: absolute;
            bottom: 60px;
            right: 20px;
            width: 400px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 12px;
            padding: 20px;
            color: #ffffff;
            font-size: 13px;
            z-index: 1000;
            max-height: 60vh;
            overflow-y: auto;
            display: none;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
        }
        
        .dependency-info-content h4 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            font-size: 14px;
        }
        
        .dependency-info-item {
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .dependency-info-item strong {
            color: #4CAF50;
        }
        
        .dependency-info-item .category {
            color: #FFD700;
            font-size: 0.8rem;
        }
        
        .dependency-info-item .description {
            color: #ccc;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }
        
        .dependency-info-item .relationships {
            margin-top: 0.5rem;
            font-size: 0.8rem;
        }
        
        .dependency-info-item .relationships ul {
            margin: 0.25rem 0 0 1rem;
            padding: 0;
        }
        
        .dependency-info-item .relationships li {
            margin: 0.1rem 0;
            color: #ccc;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 10px;
            padding: 0;
            max-width: 90%;
            max-height: 90%;
            overflow: hidden;
            color: #e0e0e0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            background: #2a2a2a;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #4CAF50;
            font-size: 1.2rem;
        }

        .modal-close {
            background: #dc3545;
            color: white;
            border: none;
            padding: 0.5rem 0.8rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .modal-close:hover {
            background: #c82333;
        }

        .modal-body {
            padding: 1.5rem;
            max-height: 70vh;
            overflow-y: auto;
        }

        .dependency-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .dependency-btn {
            padding: 0.5rem 1rem;
            border: 2px solid #667eea;
            background: #1a1a1a;
            color: #e0e0e0;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }

        .dependency-btn:hover {
            border-color: #4CAF50;
            background: #2a2a2a;
            color: #4CAF50;
        }

        .dependency-btn.active {
            background: #4CAF50;
            color: #ffffff;
            border-color: #4CAF50;
        }

        .dependency-content {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            min-height: 300px;
        }

        .dependency-graph {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .dependency-group {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 1rem;
        }

        .dependency-group h3 {
            margin: 0 0 1rem 0;
            color: #4CAF50;
            font-size: 1rem;
        }

        .dependency-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 0.5rem;
        }

        .dependency-item {
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 0.5rem;
            font-size: 0.9rem;
        }

        .dependency-item strong {
            color: #4CAF50;
        }

        .dependency-item .category {
            color: #FFD700;
            font-size: 0.8rem;
        }

        .dependency-item .description {
            color: #ccc;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #444;
            background: #1a1a1a;
            color: #e0e0e0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .zoom-btn:hover {
            border-color: #667eea;
            background: #2a2a2a;
        }

        .stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.95);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            color: #999;
            z-index: 100;
            border: 1px solid #444;
        }

        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .filter-group {
                justify-content: center;
            }
            
            
            .legend {
                position: relative;
                margin: 1rem;
                top: auto;
                right: auto;
            }
        }

        .api-diff-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding-bottom: 0;
            height: 100%;
            overflow: hidden;
        }
        
        .api-diff-workflow {
            width: 100%;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 16px;
            flex-shrink: 0;
        }
        
        .workflow-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .workflow-option {
            background: #2a2a2a;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #444;
        }
        
        .workflow-option h4 {
            color: #4CAF50;
            margin-bottom: 0.5rem;
        }
        
        .workflow-option p {
            color: #ccc;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        
        .comparison-results {
            background: #2a2a2a;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #444;
            width: 100%;
            margin-top: 0.25rem;
            position: relative;
            z-index: 1;
        }
        
        .comparison-header {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 1.5rem;
        }
        
        .comparison-side h4 {
            color: #4CAF50;
            margin-bottom: 0.5rem;
        }
        
        .comparison-content {
            margin-top: 1rem;
        }
        
        #apiDiffResults {
            width: 100%;
            background: #1a1a1a;
            flex: 1;
            height: calc(100vh - 400px);
            overflow-y: auto;
            padding: 16px;
        }
        
        /* Dark mode scrollbar styling */
        #apiDiffResults::-webkit-scrollbar {
            width: 12px;
        }
        
        #apiDiffResults::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 6px;
        }
        
        #apiDiffResults::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 6px;
            border: 2px solid #2a2a2a;
        }
        
        #apiDiffResults::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        
        #apiDiffResults::-webkit-scrollbar-corner {
            background: #2a2a2a;
        }
        .api-diff-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .api-side { background: #141414; border: 1px solid #333; border-radius: 10px; padding: 12px; }
        .api-side h3 { margin-bottom: 8px; font-size: 1rem; }
        .api-input-row { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
        .api-input-row input[type="text"] { flex: 1; min-width: 260px; padding: 8px 10px; border: 1px solid #444; border-radius: 8px; background: #1a1a1a; color: #e0e0e0; }
        .api-input-row button { padding: 8px 12px; border: 1px solid #444; background: #222; color: #e0e0e0; border-radius: 8px; cursor: pointer; }
        .api-meta { font-size: 0.8rem; color: #aaa; margin-top: 4px; }
        .api-diff-results { margin-top: 16px; background: #141414; border: 1px solid #333; border-radius: 10px; padding: 12px; }
        .diff-section { margin-top: 12px; }
        .diff-section h4 { margin-bottom: 6px; font-size: 0.95rem; }
        .diff-added { color: #4CAF50; }
        .diff-removed { color: #ff6b6b; }
        .diff-changed { color: #FFD166; }
        .diff-list { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.85rem; line-height: 1.4; }
        .diff-list li { margin: 2px 0; }
        /* Paired comparison */
        .paired-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; margin-top: 12px; }
        /* Ensure consistent column alignment for paired comparison */
        .paired-table { table-layout: fixed; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
        .paired-table th, .paired-table td { word-break: break-word; white-space: pre-wrap; }
        .paired-table th:nth-child(1), .paired-table td:nth-child(1) { width: 45%; }
        .paired-table th:nth-child(2), .paired-table td:nth-child(2) { width: 45%; }
        .paired-table th:nth-child(3), .paired-table td:nth-child(3) { width: 10%; }
        .paired-table th, .paired-table td { padding: 6px 8px; border-bottom: 1px solid #333; vertical-align: top; }
        .paired-table th { color: #aaa; text-align: left; }
        .paired-group { background: #1a1a1a; color: #ccc; font-weight: bold; cursor: pointer; user-select: none; }
        .paired-group:hover { background: #2a2a2a; }
        .paired-group::after { content: ' ▼'; float: right; }
        .paired-group.collapsed::after { content: ' ▶'; }
        .paired-group + table { display: table; }
        .paired-group.collapsed + table { display: none; }
    </style>
</head>
<body>
    <div class="header">
        <!-- Header Line: Title left, Tab buttons right -->
        <div class="header-line">
            <div class="header-left">
                <h1 id="pageTitle">LNbits Table Town</h1>
                <div id="pageSubtitle" class="header-subtitle" style="display: none;">
                    <p>Compare your dev-environment with the latest version against your productive instance</p>
                    <p class="subtitle-note">Note: Only installed and free extensions are compared</p>
                </div>
            </div>
            <div class="header-right">
                <!-- Tabs -->
                <div class="tabs">
                    <button class="tab-btn active" data-tab="schemaTab">DB Scheme</button>
                    <button class="tab-btn" data-tab="apiDiffTab">API Diff</button>
                </div>
            </div>
        </div>
        
        <!-- Controls Line: Only visible on DB Scheme tab -->
        <div class="controls" id="dbControls">
            <div class="search-container">
                <input type="text" class="search-box" placeholder="Search tables, extensions..." id="searchInput">
                <button class="search-clear" id="searchClear" style="display: none;">×</button>
            </div>
            
            <div class="filter-group">
                <span style="font-weight: bold; color: #666;">Filter by:</span>
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="onchain" style="border-color: #FFD700;"><span class="category-bubble" style="background-color: #FFD700;"></span> Onchain Features</button>
                <button class="filter-btn" data-filter="nostr" style="border-color: #6600CC;"><span class="category-bubble" style="background-color: #6600CC;"></span> Nostr Integration</button>
                <button class="filter-btn" data-filter="gaming" style="border-color: #8A0000;"><span class="category-bubble" style="background-color: #8A0000;"></span> Gaming & Entertainment</button>
                <button class="filter-btn" data-filter="ecommerce" style="border-color: #CA6702;"><span class="category-bubble" style="background-color: #CA6702;"></span> E-commerce & Business</button>
                <button class="filter-btn" data-filter="hardware" style="border-color: #1A202C;"><span class="category-bubble" style="background-color: #1A202C;"></span> Hardware & IoT</button>
                <button class="filter-btn" data-filter="communication" style="border-color: #0A9396;"><span class="category-bubble" style="background-color: #0A9396;"></span> Communication & Social</button>
            </div>
            
            <div class="analysis-group">
                <span style="font-weight: bold; color: #666;">Tools:</span>
                <button class="analysis-btn" id="exportView">📸 Export View</button>
                <button class="analysis-btn" id="printView">🖨️ Print View</button>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="schema-container" id="schemaContainer">
            <svg id="schemaSvg"></svg>
        <div class="zoom-controls">
            <button class="zoom-btn" id="zoomIn">+</button>
            <button class="zoom-btn" id="zoomOut">-</button>
            <button class="zoom-btn" id="resetZoom">⌂</button>
            </div>
        <div class="legend-explanations" id="legend-explanations">
            <h4>Field Constraints</h4>
            <div class="legend-item">
                <span class="legend-abbrev">NN</span>
                <span>NOT NULL - Field cannot be empty<br/><small>Example: id, wallet, amount</small></span>
            </div>
            <div class="legend-item">
                <span class="legend-abbrev">UQ</span>
                <span>UNIQUE - Field value must be unique<br/><small>Example: username, email, payment_hash</small></span>
            </div>
            <div class="legend-item">
                <span class="legend-abbrev">FK</span>
                    <span>FOREIGN KEY - Links to another table<br/><small>Example: wallet → Wallet.id</small></span>
            </div>
            <div class="legend-item">
                    <span class="legend-abbrev">PK</span>
                    <span>PRIMARY KEY - Unique identifier<br/><small>Example: id (UUID4)</small></span>
            </div>
            <div class="legend-item">
                    <span class="legend-abbrev">JSON</span>
                    <span>JSON data structure<br/><small>Hover for details</small></span>
            </div>
            </div>
            <!-- Toggle button for legend -->
            <button id="toggleLegend" class="legend-toggle">Legend</button>
            
            <!-- Dependency Info Modal (like legend) -->
            <div class="dependency-info-modal" id="dependencyInfoModal">
                <div class="dependency-info-content">
                    <h4>Table Dependencies</h4>
                    <div id="dependencyInfoContent">
                        <!-- Dependency info will be rendered here -->
                </div>
                </div>
                </div>
                </div>
        <div class="api-diff-container" id="apiDiffTab" style="display:none">
            <!-- Search/Input Section - Fixed at top -->
            <div class="api-diff-workflow">
                <h3></h3>
                <div class="workflow-options">
                    <div class="workflow-option">
                        <h4>Compare Your Installation to demo.lnbits.com</h4>
                        <p>Note that some endpoints are hidden on demo server which shows here as removal!</p>
                        <div class="api-input-row">
                            <input type="text" id="originUrl" placeholder="https://demo.lnbits.com" />
                            <button id="compareToDemo">Compare to demo.lnbits.com</button>
                </div>
            </div>
            
                    <div class="workflow-option">
                        <h4>Compare Two Custom URLs</h4>
                        <p>Compare any two LNbits instances</p>
                        <div class="api-input-row">
                            <input type="text" id="leftUrl" placeholder="https://first-instance or e.g. bitcoindelta.club" />
                            <input type="text" id="rightUrl" placeholder="https://second-instance or domain.com" />
                            <button id="compareCustom">Compare URLs</button>
                </div>
                </div>
                </div>
                </div>
            
            <!-- Results Section - Below search, scrollable -->
            <div id="apiDiffResults" style="display:none;">
                <div class="comparison-results">
                    <div class="comparison-header">
                        <div class="comparison-side">
                            <h4 id="leftTitle">Left Side</h4>
                            <div class="api-meta" id="leftMeta">No spec loaded.</div>
                </div>
                        <div class="comparison-side">
                            <h4 id="rightTitle">Right Side</h4>
                            <div class="api-meta" id="rightMeta">No spec loaded.</div>
                </div>
            </div>
            
                    <div class="comparison-content" id="comparisonContent">
                        <!-- Results will be populated here -->
                </div>
            
                    <div id="apiDiffSummary"></div>
                    <div class="split-columns" id="splitColumns" style="display:flex;gap:12px;align-items:flex-start;margin-top:8px;">
                        <div class="split-col" id="leftChanges" style="flex:1 1 0;min-width:0;"><h4 style="color:#ccc">Left (baseline)</h4></div>
                        <div class="split-col" id="rightChanges" style="flex:1 1 0;min-width:0;"><h4 style="color:#ccc">Right (comparison)</h4></div>
                </div>
                    <div id="pairedCompare"></div>
                </div>
            </div>
        </div>
        
        
        
        <!-- Stats removed as requested -->
        
        
        
            </div>
            
    <div class="tooltip" id="tooltip" style="display: none;"></div>
    
    <!-- Dependency Analysis Modal -->
    <div id="dependencyModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🔗 Extension Dependency Analysis</h2>
                <button class="modal-close" onclick="closeDependencyModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="dependency-controls">
                    <button class="dependency-btn" id="showAllDeps">Show All Dependencies</button>
                    <button class="dependency-btn" id="showCoreDeps">Core Dependencies Only</button>
                    <button class="dependency-btn" id="showExtDeps">Extension-to-Extension</button>
            </div>
                <div id="dependencyContent" class="dependency-content">
                    <!-- Dependency analysis will be rendered here -->
            </div>
            </div>
        </div>
    </div>

    <script>
        // Load comprehensive data from JSON file (embedded for file:// compatibility)
        let schemaData = null;
        let selectedTable = null;
        let tablePositions = {};
        let fieldPositions = {};
        
        // Embedded full data (keeps all extensions visible even without fetch)
        const embeddedSchemaData = 
        
        {"core":{"name":"Core LNbits","color":"#FF1493","description":"Complete LNbits database schema - all core tables and extension fields","tables":[{"name":"Account","description":"User accounts and authentication","technical":"Primary key: id (UUID4), stores user credentials, permissions, external_id for SSO, extra user data","fields":["id","external_id","username","password_hash","pubkey","email","extra","created_at","updated_at"]},{"name":"Wallet","description":"Lightning wallets for users","technical":"Primary key: id, foreign key: user → Account.id, stores adminkey, inkey, balance, extra wallet data","fields":["id","user","name","adminkey","inkey","deleted","created_at","updated_at","currency","balance_msat","extra"]},{"name":"Payment","description":"Payment transaction records","technical":"Primary key: checking_id, foreign key: wallet_id → Wallet.id, tracks all payments with full metadata","fields":["checking_id","payment_hash","wallet_id","amount","fee","bolt11","fiat_provider","status","memo","expiry","webhook","webhook_status","preimage","tag","extension","time","created_at","updated_at","extra"]},{"name":"AccessControlList","description":"API access control","technical":"Primary key: id, manages API permissions and endpoints","fields":["id","name","endpoints","token_id_list"]},{"name":"UserAcls","description":"User access control lists","technical":"Primary key: id, user-specific permissions and ACLs","fields":["id","access_control_list","updated_at"]},{"name":"TinyURL","description":"URL shortening service","technical":"Primary key: id, manages short URL redirects with access control","fields":["id","url","endless","wallet","time"]},{"name":"WebPushSubscription","description":"Web push notifications","technical":"Foreign key: user → Account.id, manages push notification subscriptions","fields":["endpoint","user","data","host","timestamp"]}]},"extensions":{ "lnurlp": {"name":"Pay Links","category":"ecommerce","color":"#CA6702","description":"Create static payment links and Lightning Addresses","technical":"LNURL-pay implementation with Lightning Address support","tables":[{"name":"PayLink","description":"Static payment links","technical":"Foreign key: wallet → Wallet.id, stores payment link configuration with LNURL-pay support","fields":["id","wallet","description","min","max","served_meta","served_pr","comment_chars","created_at","updated_at","username","zaps","webhook_url","webhook_headers","webhook_body","success_text","success_url","currency","fiat_base_multiplier","disposable","domain"]},{"name":"LnurlpSettings","description":"Extension settings","technical":"Stores Nostr private key for zaps functionality","fields":["nostr_private_key"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/lnurlp"},"withdraw":{"name":"Withdraw Links","category":"ecommerce","color":"#CA6702","description":"Create LNURL withdraw links for users","technical":"LNURL-withdraw implementation for Lightning withdrawals","tables":[{"name":"WithdrawLink","description":"Withdraw link configurations","technical":"Foreign key: wallet → Wallet.id, manages withdrawal links with LNURL-withdraw support","fields":["id","wallet","title","min_withdrawable","max_withdrawable","uses","wait_time","is_unique","unique_hash","k1","open_time","used","usescsv","number","webhook_url","webhook_headers","webhook_body","custom_url","created_at"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/withdraw"},"boltcards":{"name":"Bolt Cards","category":"ecommerce","color":"#CA6702","description":"Self-custody NFC card payments","technical":"NXP NTAG424 Bolt Card implementation with one-time LNURLw","tables":[{"name":"Card","description":"Bolt card configurations","technical":"Foreign key: wallet → Wallet.id, stores card data, encryption keys k0/k1/k2, and settings","fields":["id","wallet","card_name","uid","external_id","counter","tx_limit","daily_limit","enable","k0","k1","k2","prev_k0","prev_k1","prev_k2","otp","time"]},{"name":"Hit","description":"Card usage tracking","technical":"Foreign key: card_id → Card.id, tracks card taps and payments","fields":["id","card_id","ip","spent","useragent","old_ctr","new_ctr","amount","time"]},{"name":"Refund","description":"Card refund tracking","technical":"Foreign key: hit_id → Hit.id, tracks refunds for card payments","fields":["id","hit_id","refund_amount","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/boltcards"},"satspay":{"name":"SatsPay Server","category":"ecommerce","color":"#CA6702","description":"Accept Bitcoin payments on your website or app","technical":"Creates onchain and Lightning invoices for web integration","tables":[{"name":"Charge","description":"Payment charges","technical":"Foreign key: user → Account.id, stores charge configurations with onchain/Lightning support","fields":["id","user","amount","time","timestamp","balance","pending","zeroconf","fasttrack","paid","completelinktext","name","description","onchainwallet","onchainaddress","lnbitswallet","payment_request","payment_hash","webhook","completelink","custom_css","currency","currency_amount","extra"]},{"name":"SatsPayPayment","description":"Payment records","technical":"Links to core Payment table, tracks SatsPay transactions","fields":["id","charge_id","payment_hash","amount","status","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/satspay"},"boltz":{"name":"Boltz","category":"onchain","color":"#FFD700","description":"Swap between onchain and Lightning payments","technical":"Onchain/offchain swaps with Liquid support","tables":[{"name":"SubmarineSwap","description":"Submarine swap transactions","technical":"Foreign key: wallet → Wallet.id, manages submarine swaps (onchain→Lightning)","fields":["id","wallet","asset","amount","direction","feerate","feerate_value","payment_hash","time","status","refund_privkey","refund_address","boltz_id","expected_amount","timeout_block_height","address","bip21","redeem_script","blinding_key"]},{"name":"BoltzSwap","description":"Boltz swap transactions","technical":"Foreign key: wallet → Wallet.id, manages Boltz swaps","fields":["id","wallet","amount","direction","asset","feerate","payment_hash","time","status","boltz_id","expected_amount","address","bip21"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/boltz"},"watchonly":{"name":"Onchain Wallet","category":"onchain","color":"#FFD700","description":"Monitor onchain Bitcoin addresses","technical":"Watch-only wallet implementation for onchain monitoring","tables":[{"name":"WalletAccount","description":"Watch-only wallet configurations","technical":"Foreign key: user → Account.id, stores masterpub (xpub), fingerprint, address_no, and metadata","fields":["id","user","masterpub","fingerprint","title","address_no","balance","type","network","meta"]},{"name":"BtcAddress","description":"Onchain Bitcoin addresses","technical":"Stores Bitcoin addresses for monitoring and payments","fields":["id","address","label","balance","tx_count","last_used","created_at"]}],"dependencies":["account"],"github":"https://github.com/lnbits/watchonly"},"nostrmarket":{"name":"Nostr Market","category":"nostr","color":"#6600CC","description":"Sell products on Nostr marketplace","technical":"Nostr webshop/marketplace integration with Lightning payments","tables":[{"name":"NostrProduct","description":"Marketplace products","technical":"Foreign key: wallet → Wallet.id, stores product information","fields":["id","wallet","name","description","image","price","nostr_public_key"]},{"name":"NostrOrder","description":"Customer orders","technical":"Links to core Payment table, tracks marketplace orders","fields":["id","product_id","payment_hash","buyer_pubkey","status","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/nostrmarket"},"nostrrelay":{"name":"Nostr Relay","category":"nostr","color":"#6600CC","description":"Launch your own Nostr relay","technical":"One-click Nostr relay deployment and management","tables":[{"name":"NostrRelay","description":"Relay configurations","technical":"Foreign key: wallet → Wallet.id, manages relay settings","fields":["id","wallet","name","description","public_key","relay_url","active"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/nostrrelay"},"nostrclient":{"name":"Nostr Client","category":"nostr","color":"#6600CC","description":"Nostr client for extensions","technical":"Nostr event multiplexer and client functionality","tables":[{"name":"NostrClient","description":"Client configurations","technical":"Foreign key: wallet → Wallet.id, stores client settings","fields":["id","wallet","name","public_key","private_key","relays"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/nostrclient"},"nostrnip5":{"name":"Nostr NIP-5","category":"nostr","color":"#6600CC","description":"Verify addresses for Nostr NIP-5","technical":"NIP-5 address verification and management","tables":[{"name":"NostrNip5","description":"NIP-5 address configurations","technical":"Foreign key: wallet → Wallet.id, manages NIP-5 addresses","fields":["id","wallet","name","domain","public_key","verified"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/nostrnip5"},"satsdice":{"name":"Sats Dice","category":"gaming","color":"#8A0000","description":"Play provably fair dice games","technical":"LNURL Satoshi dice implementation with provable fairness","tables":[{"name":"SatsdiceLink","description":"Dice game sessions","technical":"Foreign key: wallet → Wallet.id, manages dice game sessions","fields":["id","wallet","title","min_bet","max_bet","multiplier","haircut","chance","base_url","amount","served_meta","served_pr","disposable","open_time"]},{"name":"SatsDiceBet","description":"Individual bets","technical":"Links to core Payment table, tracks individual bets","fields":["id","game_id","payment_hash","amount","target","roll","won","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/satsdice"},"coinflip":{"name":"Coinflip","category":"gaming","color":"#8A0000","description":"Bet sats on coinflips","technical":"Provably fair coinflip betting system","tables":[{"name":"CoinflipSettings","description":"Coinflip game settings","technical":"Foreign key: wallet_id → Wallet.id, manages coinflip game settings","fields":["id","wallet_id","user_id","max_players","max_bet","enabled","haircut"]},{"name":"Coinflip","description":"Coinflip game sessions","technical":"Foreign key: settings_id → CoinflipSettings.id, manages coinflip games","fields":["id","settings_id","name","number_of_players","buy_in","players","completed","created_at"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/coinflip"},"numbers":{"name":"Numbers","category":"gaming","color":"#8A0000","description":"Block-based numbers game","technical":"A provably fair numbers game powered by Bitcoin block data","tables":[{"name":"NumbersGame","description":"Numbers game sessions","technical":"Foreign key: wallet → Wallet.id, manages numbers games","fields":["id","wallet","name","max_bet","min_bet","active"]},{"name":"NumbersBet","description":"Individual number bets","technical":"Links to core Payment table, tracks number bets","fields":["id","game_id","payment_hash","amount","number","block_hash","won","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/numbers"},"eightball":{"name":"Magic 8ball","category":"gaming","color":"#8A0000","description":"MadBitcoin's Magic Eightball","technical":"Pay sats to get random words/responses","tables":[{"name":"EightballGame","description":"8ball game configurations","technical":"Foreign key: wallet → Wallet.id, manages 8ball games","fields":["id","wallet","name","price","responses","active"]},{"name":"EightballResponse","description":"Individual responses","technical":"Links to core Payment table, tracks 8ball responses","fields":["id","game_id","payment_hash","response","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/eightball"},"events":{"name":"Events","category":"ecommerce","color":"#CA6702","description":"Sell event tickets and manage attendees","technical":"Event ticket sales and registration system","tables":[{"name":"Event","description":"Event information","technical":"Foreign key: wallet → Wallet.id, stores event details","fields":["id","wallet","name","description","start_date","end_date","price","max_tickets"]},{"name":"EventTicket","description":"Ticket sales","technical":"Links to core Payment table, tracks ticket sales","fields":["id","event_id","payment_hash","attendee_name","attendee_email","status","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/events"},"invoices":{"name":"Invoices","category":"ecommerce","color":"#CA6702","description":"Create invoices for your clients","technical":"Professional invoice creation and management system","tables":[{"name":"Invoice","description":"Invoice configurations","technical":"Foreign key: wallet → Wallet.id, stores invoice details","fields":["id","wallet","name","description","amount","currency","due_date","status"]},{"name":"InvoicePayment","description":"Invoice payments","technical":"Links to core Payment table, tracks invoice payments","fields":["id","invoice_id","payment_hash","amount","status","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/invoices"},"paywall":{"name":"Paywall","category":"ecommerce","color":"#CA6702","description":"Create paywalls for content","technical":"Content paywall system with Lightning payments","tables":[{"name":"Paywall","description":"Paywall configurations","technical":"Foreign key: wallet → Wallet.id, stores paywall settings","fields":["id","wallet","name","description","price","content","active"]},{"name":"PaywallAccess","description":"Paywall access records","technical":"Links to core Payment table, tracks paywall access","fields":["id","paywall_id","payment_hash","access_granted","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/paywall"},"bitcoinswitch":{"name":"Bitcoin Switch","category":"hardware","color":"#1A202C","description":"Control devices with Bitcoin payments","technical":"IoT device control via Lightning payments","tables":[{"name":"BitcoinSwitch","description":"Switch configurations","technical":"Foreign key: wallet → Wallet.id, stores switch settings","fields":["id","wallet","name","description","price","gpio_pin","active"]},{"name":"SwitchAction","description":"Device actions","technical":"Links to core Payment table, tracks switch activations","fields":["id","switch_id","payment_hash","action","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/bitcoinswitch_extension"},"lnurldevice":{"name":"LNURLDevices","category":"hardware","color":"#1A202C","description":"Control IoT devices with LNURL","technical":"Points of sale, ATMs, switches via LNURL","tables":[{"name":"LNURLDevice","description":"Device configurations","technical":"Foreign key: wallet → Wallet.id, stores device settings","fields":["id","wallet","title","device","currency","amount","pin","active"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/lnurldevice"},"tipjar":{"name":"Tip Jar","category":"communication","color":"#0A9396","description":"Accept Bitcoin donations with messages","technical":"Donation system with message attachments","tables":[{"name":"TipJar","description":"Tip jar configurations","technical":"Foreign key: wallet → Wallet.id, stores tip jar settings","fields":["id","wallet","name","description","amount","webhook_url","active"]},{"name":"Tip","description":"Individual tips","technical":"Links to core Payment table, tracks individual tips","fields":["id","tipjar_id","payment_hash","amount","message","time"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/tipjar"},"streamalerts":{"name":"Stream Alerts","category":"communication","color":"#0A9396","description":"Bitcoin donations in stream alerts","technical":"Streaming platform integration for Bitcoin donations","tables":[{"name":"StreamAlert","description":"Stream alert configurations","technical":"Foreign key: wallet → Wallet.id, stores alert settings","fields":["id","wallet","name","description","amount","platform","webhook_url","active"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/streamalerts"},"copilot":{"name":"Streamer Copilot","category":"communication","color":"#0A9396","description":"Video tips/animations/webhooks for streamers","technical":"Streaming tools with Lightning payment integration","tables":[{"name":"CopilotAlert","description":"Streamer alert configurations","technical":"Foreign key: wallet → Wallet.id, stores alert settings","fields":["id","wallet","name","description","amount","animation","sound","active"]}],"dependencies":["wallet"],"github":"https://github.com/lnbits/copilot"}},"categories":{"core":{"name":"Core LNbits","color":"#0066CC","description":"Core database tables for LNbits functionality"},"payment":{"name":"Payment Extensions","color":"#00AA44","description":"Extensions for Lightning payment processing"},"onchain":{"name":"Onchain Features","color":"#FF6600","description":"Extensions with Bitcoin onchain functionality"},"nostr":{"name":"Nostr Integration","color":"#6600CC","description":"Extensions integrating with Nostr protocol"},"gaming":{"name":"Gaming & Entertainment","color":"#FFAA00","description":"Gaming and entertainment extensions"},"ecommerce":{"name":"E-commerce & Business","color":"#CC0000","description":"Business and e-commerce extensions"},"hardware":{"name":"Hardware & IoT","color":"#333333","description":"Hardware and IoT device control extensions"},"communication":{"name":"Communication & Social","color":"#8B4513","description":"Communication and social media extensions"}}};

        async function loadSchemaData() {
            try {
                // Use embedded data directly for file:// compatibility
        schemaData = embeddedSchemaData;
        
        // Add datatypes to core tables
        schemaData.core.tables.forEach(table => {
            if (!table.datatypes) {
                table.datatypes = table.fields.map(field => {
                            if (field === 'id' || field === 'checking_id') return 'UUID4';
                            if (field === 'wallet' || field === 'user' || field === 'wallet_id' || field === 'access_control_list') return 'UUID4';
                            if (field === 'amount' || field === 'fee' || field === 'balance_msat' || field === 'price') return 'BIGINT';
                            if (field === 'created_at' || field === 'updated_at' || field === 'time') return 'TIMESTAMP';
                            if (field === 'deleted' || field === 'active') return 'BOOLEAN';
                            if (field === 'endpoints' || field === 'token_id_list') return 'JSON';
                    return 'TEXT';
                });
            }
        });
        
        // Add datatypes to extension tables
        Object.values(schemaData.extensions).forEach(ext => {
            ext.tables.forEach(table => {
                if (!table.datatypes) {
                    table.datatypes = table.fields.map(field => {
                                if (field === 'id') return 'UUID4';
                                if (field === 'wallet' || field === 'user') return 'UUID4';
                                if (field === 'amount' || field === 'price' || field === 'fee') return 'BIGINT';
                                if (field === 'created_at' || field === 'updated_at' || field === 'time') return 'TIMESTAMP';
                                if (field === 'active' || field === 'deleted') return 'BOOLEAN';
                                if (field === 'multiplier') return 'DECIMAL';
                                if (field === 'max_tickets' || field === 'gpio_pin') return 'INTEGER';
                        return 'TEXT';
                    });
                }
            });
        });
            } catch (e) {
                console.error('Failed to load schema; using embedded data', e);
                schemaData = embeddedSchemaData;
            }
        }
        
        // Note: datatype augmentation is performed after data is loaded in loadSchemaData()

        // Initialize the visualization
        let svg, g, zoom;
        let currentFilter = "all";
        let userHasZoomed = false;
        let hasInitialFit = false;

        function initializeVisualization() {
            // Ensure data is loaded, then render
            if (!schemaData) {
                loadSchemaData().then(() => {
                    buildSvgAndRender();
                });
            } else {
                buildSvgAndRender();
            }
        }

        function buildSvgAndRender() {
            
            const container = document.getElementById('schemaContainer');
            const containerRect = container.getBoundingClientRect();
            
            // Use full viewport height for SVG
            const svgHeight = window.innerHeight - 200;
            
            svg = d3.select("#schemaSvg")
                .attr("width", containerRect.width)
                .attr("height", svgHeight);

            g = svg.append("g");

            // Set up zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                    userHasZoomed = true;
                });

            svg.call(zoom);

            // Initial render
            renderSchema();
            setupSvgClickHandler();
            // Auto-fit to top rows after first render
            requestAnimationFrame(() => {
                fitToTopRows(20);
                hasInitialFit = true;
                userHasZoomed = false;
            });
        }

        function fitToContent(padding) {
            if (!g || !svg) return;
            
            // Get all table groups
            const tableGroups = g.selectAll('.table-group').nodes();
            if (tableGroups.length === 0) return;
            
            // Calculate bounding box of all tables
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            tableGroups.forEach(group => {
                const transform = d3.select(group).attr('transform');
                if (transform) {
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    if (match) {
                        const x = parseFloat(match[1]);
                        const y = parseFloat(match[2]);
                        
                        // Get table dimensions
                        const rect = group.querySelector('rect');
                        if (rect) {
                            const width = parseFloat(rect.getAttribute('width'));
                            const height = parseFloat(rect.getAttribute('height'));
                            
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x + width);
                            maxY = Math.max(maxY, y + height);
                        }
                    }
                }
            });
            
            if (minX === Infinity) return;
            
            // Add padding
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;
            
            // Calculate scale and translation
            const svgWidth = svg.attr('width');
            const svgHeight = svg.attr('height');
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            
            const scaleX = svgWidth / contentWidth;
            const scaleY = svgHeight / contentHeight;
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 1
            
            const translateX = (svgWidth - contentWidth * scale) / 2 - minX * scale;
            const translateY = (svgHeight - contentHeight * scale) / 2 - minY * scale;
            
            // Apply transform
            const transform = d3.zoomIdentity.translate(translateX, translateY).scale(scale);
            svg.transition().duration(750).call(zoom.transform, transform);
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Only initialize if not already initialized
            if (!window.visualizationInitialized) {
            initializeVisualization();
                initLegendToggle();
                window.visualizationInitialized = true;
            }
        });

        // Enhanced field information function
        function highlightSearchTerm(text, searchTerm) {
            if (!searchTerm) return text;
            
            // For SVG text, we can't use HTML markup, so just return the text
            // The highlighting will be done by changing the text color
            return text;
        }
        
        function getHighlightedTextColor(searchTerm, text, defaultColor) {
            if (!searchTerm || !text.toLowerCase().includes(searchTerm.toLowerCase())) {
                return defaultColor;
            }
            // Use different colors based on background
            if (defaultColor === '#000') {
                return '#FF6B35'; // Orange-red for white backgrounds (core table headers)
            } else {
                return '#FFD700'; // Yellow for dark backgrounds
            }
        }

        function getFieldInfo(fieldName, dataType) {
            const fieldInfo = {
                // Common field patterns with legend abbreviations
                'id': { type: 'UUID4', length: '36', example: '550e8400-e29b-41d4-a716-446655440000', constraints: 'NN UQ' },
                'checking_id': { type: 'UUID4', length: '36', example: '550e8400-e29b-41d4-a716-446655440000', constraints: 'NN UQ' },
                'wallet': { type: 'UUID4', length: '36', example: '550e8400-e29b-41d4-a716-446655440000', constraints: 'NN FK' },
                'wallet_id': { type: 'UUID4', length: '36', example: '550e8400-e29b-41d4-a716-446655440000', constraints: 'NN FK' },
                'user': { type: 'UUID4', length: '36', example: '550e8400-e29b-41d4-a716-446655440000', constraints: 'NN FK' },
                'username': { type: 'TEXT', length: '50', example: 'alice', constraints: 'NN UQ' },
                'email': { type: 'TEXT', length: '255', example: 'alice@example.com', constraints: 'UQ' },
                'password_hash': { type: 'TEXT', length: '255', example: '$2b$12$...', constraints: 'NN' },
                'pubkey': { type: 'TEXT', length: '66', example: '02a1b2c3...', constraints: 'UQ' },
                'adminkey': { type: 'TEXT', length: '43', example: 'admin_...', constraints: 'NN UQ' },
                'inkey': { type: 'TEXT', length: '43', example: 'invoice_...', constraints: 'NN UQ' },
                'name': { type: 'TEXT', length: '100', example: 'My Wallet', constraints: 'NN' },
                'amount': { type: 'BIGINT', length: '8', example: '1000', constraints: 'NN' },
                'balance_msat': { type: 'BIGINT', length: '8', example: '1000000', constraints: 'NN DEF0' },
                'fee': { type: 'BIGINT', length: '8', example: '10', constraints: 'DEF0' },
                'payment_hash': { type: 'TEXT', length: '64', example: 'a1b2c3...', constraints: 'UQ' },
                'bolt11': { type: 'TEXT', length: '1000', example: 'lnbc10u1p...', constraints: 'NN' },
                'status': { type: 'TEXT', length: '20', example: 'pending', constraints: 'NN' },
                'memo': { type: 'TEXT', length: '500', example: 'Payment for services', constraints: '' },
                'description': { type: 'TEXT', length: '500', example: 'Payment description', constraints: '' },
                'created_at': { type: 'TIMESTAMP', length: '8', example: '2024-01-01 12:00:00', constraints: 'NN DEFNOW' },
                'updated_at': { type: 'TIMESTAMP', length: '8', example: '2024-01-01 12:00:00', constraints: 'DEFNOW' },
                'deleted': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEF0' },
                'active': { type: 'BOOLEAN', length: '1', example: 'true', constraints: 'DEF1' },
                'currency': { type: 'TEXT', length: '3', example: 'BTC', constraints: 'DEFsat' },
                'time': { type: 'TIMESTAMP', length: '8', example: '2024-01-01 12:00:00', constraints: 'NN' },
                'extension': { type: 'TEXT', length: '50', example: 'lnurlp', constraints: 'NN' },
                'endpoints': { type: 'JSON', length: '1000', example: '{"read": true}', constraints: '' },
                'token_id_list': { type: 'JSON', length: '1000', example: '["token1", "token2"]', constraints: '' },
                'access_control_list': { type: 'UUID4', length: '36', example: '550e8400-e29b-41d4-a716-446655440000', constraints: 'NN FK' },
                // Extension-specific fields
                'title': { type: 'TEXT', length: '100', example: 'My Payment Link', constraints: 'NN' },
                'min': { type: 'TEXT', length: '20', example: '1000', constraints: 'NN' },
                'max': { type: 'TEXT', length: '20', example: '1000000', constraints: 'NN' },
                'webhook_url': { type: 'TEXT', length: '500', example: 'https://example.com/webhook', constraints: '' },
                'success_text': { type: 'TEXT', length: '200', example: 'Payment successful!', constraints: '' },
                'min_withdrawable': { type: 'TEXT', length: '20', example: '1000', constraints: 'NN' },
                'max_withdrawable': { type: 'TEXT', length: '20', example: '1000000', constraints: 'NN' },
                'uses': { type: 'TEXT', length: '10', example: '10', constraints: 'NN' },
                'used': { type: 'TEXT', length: '10', example: '3', constraints: 'DEF0' },
                'unique_hash': { type: 'TEXT', length: '64', example: 'a1b2c3...', constraints: 'UQ' },
                'card_name': { type: 'TEXT', length: '50', example: 'My Bolt Card', constraints: 'NN' },
                'uid': { type: 'TEXT', length: '14', example: '04:12:34:56:78:90:ab', constraints: 'NN UQ' },
                'counter': { type: 'BIGINT', length: '8', example: '0', constraints: 'DEF0' },
                'tx_limit': { type: 'BIGINT', length: '8', example: '100000', constraints: 'NN' },
                'daily_limit': { type: 'BIGINT', length: '8', example: '1000000', constraints: 'NN' },
                'enable': { type: 'BOOLEAN', length: '1', example: 'true', constraints: 'DEF1' },
                'onchainwallet': { type: 'TEXT', length: '100', example: 'wallet_id_123', constraints: 'NN' },
                'lnbitswallet': { type: 'TEXT', length: '100', example: 'wallet_id_456', constraints: 'NN' },
                'charge_id': { type: 'UUID4', length: '36', example: '550e8400-e29b-41d4-a716-446655440000', constraints: 'NN FK' },
                'address': { type: 'TEXT', length: '100', example: 'bc1q...', constraints: 'NN' },
                'expected_amount': { type: 'BIGINT', length: '8', example: '100000', constraints: 'NN' },
                'refund_privkey': { type: 'TEXT', length: '64', example: 'L1aW4aubDFB7yfras2S1mN3bqg9nwySY8nkoLmJebSxDf3SfGjZ', constraints: 'NN' },
                'nostr_private_key': { type: 'TEXT', length: '64', example: 'nsec1...', constraints: '' },
                'nostr_public_key': { type: 'TEXT', length: '66', example: 'npub1...', constraints: 'NN' },
                'image': { type: 'TEXT', length: '500', example: 'https://example.com/image.jpg', constraints: '' },
                'buyer_pubkey': { type: 'TEXT', length: '66', example: 'npub1...', constraints: 'NN' },
                'relay_url': { type: 'TEXT', length: '200', example: 'wss://relay.example.com', constraints: 'NN' },
                'public_key': { type: 'TEXT', length: '66', example: 'npub1...', constraints: 'NN' },
                'private_key': { type: 'TEXT', length: '64', example: 'nsec1...', constraints: 'NN' },
                'relays': { type: 'JSON', length: '1000', example: '["wss://relay1.com", "wss://relay2.com"]', constraints: '' },
                'domain': { type: 'TEXT', length: '100', example: 'example.com', constraints: 'NN' },
                'verified': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEF0' },
                'multiplier': { type: 'DECIMAL', length: '10,2', example: '2.5', constraints: 'NN' },
                'max_bet': { type: 'BIGINT', length: '8', example: '1000000', constraints: 'NN' },
                'min_bet': { type: 'BIGINT', length: '8', example: '1000', constraints: 'NN' },
                'target': { type: 'BIGINT', length: '8', example: '50', constraints: 'NN' },
                'roll': { type: 'BIGINT', length: '8', example: '75', constraints: 'NN' },
                'won': { type: 'BOOLEAN', length: '1', example: 'true', constraints: 'NN' },
                'choice': { type: 'TEXT', length: '10', example: 'heads', constraints: 'NN' },
                'result': { type: 'TEXT', length: '10', example: 'tails', constraints: 'NN' },
                'number': { type: 'BIGINT', length: '8', example: '42', constraints: 'NN' },
                'block_hash': { type: 'TEXT', length: '64', example: '0000000000000000000...', constraints: 'NN' },
                'responses': { type: 'JSON', length: '1000', example: '["Yes", "No", "Maybe"]', constraints: '' },
                'response': { type: 'TEXT', length: '100', example: 'Yes', constraints: 'NN' },
                'start_date': { type: 'TIMESTAMP', length: '8', example: '2024-01-01 12:00:00', constraints: 'NN' },
                'end_date': { type: 'TIMESTAMP', length: '8', example: '2024-01-02 12:00:00', constraints: 'NN' },
                'max_tickets': { type: 'INTEGER', length: '4', example: '100', constraints: 'NN' },
                'attendee_name': { type: 'TEXT', length: '100', example: 'John Doe', constraints: 'NN' },
                'attendee_email': { type: 'TEXT', length: '255', example: 'john@example.com', constraints: 'NN' },
                'due_date': { type: 'TIMESTAMP', length: '8', example: '2024-01-15 23:59:59', constraints: 'NN' },
                'content': { type: 'TEXT', length: '5000', example: 'Premium content here...', constraints: '' },
                'access_granted': { type: 'BOOLEAN', length: '1', example: 'true', constraints: 'DEF1' },
                'gpio_pin': { type: 'INTEGER', length: '4', example: '18', constraints: 'NN' },
                'action': { type: 'TEXT', length: '20', example: 'toggle', constraints: 'NN' },
                'device': { type: 'TEXT', length: '50', example: 'switch', constraints: 'NN' },
                'pin': { type: 'TEXT', length: '10', example: '1234', constraints: 'NN' },
                'message': { type: 'TEXT', length: '500', example: 'Thanks for the tip!', constraints: '' },
                'platform': { type: 'TEXT', length: '50', example: 'twitch', constraints: 'NN' },
                'animation': { type: 'TEXT', length: '100', example: 'rainbow', constraints: '' },
                'sound': { type: 'TEXT', length: '100', example: 'notification.mp3', constraints: '' },
                
                // Core model extra fields
                'extra': { type: 'JSON', length: '2000', example: '{"icon":"flash_on","color":"primary"}', constraints: '' },
                'fiat_provider': { type: 'TEXT', length: '50', example: 'coingecko', constraints: '' },
                'expiry': { type: 'TIMESTAMP', length: '8', example: '2024-01-15 10:30:00', constraints: '' },
                'webhook_status': { type: 'TEXT', length: '20', example: 'pending', constraints: '' },
                'preimage': { type: 'TEXT', length: '64', example: 'a1b2c3...', constraints: '' },
                'tag': { type: 'TEXT', length: '50', example: 'payment', constraints: '' },
                
                // WatchOnly extension fields (actual repository fields)
                'masterpub': { type: 'TEXT', length: '111', example: 'xpub6...', constraints: 'NN' },
                'fingerprint': { type: 'TEXT', length: '8', example: 'a1b2c3d4', constraints: '' },
                'address_no': { type: 'INTEGER', length: '4', example: '0', constraints: 'NN DEF0' },
                'type': { type: 'TEXT', length: '20', example: 'watch-only', constraints: '' },
                'network': { type: 'TEXT', length: '10', example: 'Mainnet', constraints: 'NN DEFMainnet' },
                'meta': { type: 'JSON', length: '1000', example: '{"version":"1.0"}', constraints: '' },
                
                // BoltCard extension fields (actual repository fields)
                'external_id': { type: 'TEXT', length: '50', example: 'ext_123', constraints: 'EXT' },
                'k0': { type: 'TEXT', length: '32', example: '00000000000000000000000000000000', constraints: 'NN' },
                'k1': { type: 'TEXT', length: '32', example: '00000000000000000000000000000000', constraints: 'NN' },
                'k2': { type: 'TEXT', length: '32', example: '00000000000000000000000000000000', constraints: 'NN' },
                'prev_k0': { type: 'TEXT', length: '32', example: '00000000000000000000000000000000', constraints: 'NN' },
                'prev_k1': { type: 'TEXT', length: '32', example: '00000000000000000000000000000000', constraints: 'NN' },
                'prev_k2': { type: 'TEXT', length: '32', example: '00000000000000000000000000000000', constraints: 'NN' },
                'otp': { type: 'TEXT', length: '32', example: '00000000000000000000000000000000', constraints: 'NN' },
                
                // LNURL-pay extension fields
                'served_meta': { type: 'INTEGER', length: '8', example: '0', constraints: 'NN DEF0' },
                'served_pr': { type: 'INTEGER', length: '8', example: '0', constraints: 'NN DEF0' },
                'comment_chars': { type: 'INTEGER', length: '3', example: '0', constraints: 'NN DEF0' },
                'zaps': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                'webhook_headers': { type: 'TEXT', length: '500', example: '{"Authorization":"Bearer token"}', constraints: '' },
                'webhook_body': { type: 'TEXT', length: '1000', example: '{"amount":1000,"memo":"Payment"}', constraints: '' },
                'success_url': { type: 'TEXT', length: '200', example: 'https://example.com/success', constraints: '' },
                'fiat_base_multiplier': { type: 'INTEGER', length: '6', example: '100', constraints: 'DEF100' },
                'disposable': { type: 'BOOLEAN', length: '1', example: 'true', constraints: 'DEFtrue' },
                'domain': { type: 'TEXT', length: '100', example: 'example.com', constraints: '' },
                
                // Withdraw extension fields
                'wait_time': { type: 'INTEGER', length: '4', example: '60', constraints: 'NN' },
                'is_unique': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                'k1': { type: 'TEXT', length: '64', example: 'a1b2c3d4...', constraints: '' },
                'open_time': { type: 'INTEGER', length: '8', example: '1640995200', constraints: 'NN' },
                'usescsv': { type: 'TEXT', length: '1000', example: 'user1,user2,user3', constraints: '' },
                'number': { type: 'INTEGER', length: '4', example: '0', constraints: 'DEF0' },
                'custom_url': { type: 'TEXT', length: '200', example: 'https://example.com/custom', constraints: '' },
                
                // SatsPay extension fields
                'time': { type: 'INTEGER', length: '8', example: '3600', constraints: 'NN' },
                'timestamp': { type: 'TIMESTAMP', length: '8', example: '2024-01-15 10:30:00', constraints: 'NN' },
                'balance': { type: 'INTEGER', length: '8', example: '0', constraints: 'NN DEF0' },
                'pending': { type: 'INTEGER', length: '8', example: '0', constraints: 'NN DEF0' },
                'zeroconf': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                'fasttrack': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                'paid': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                'completelinktext': { type: 'TEXT', length: '50', example: 'Back to Site', constraints: 'DEF' },
                'onchainaddress': { type: 'TEXT', length: '62', example: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh', constraints: '' },
                'payment_request': { type: 'TEXT', length: '1000', example: 'lnbc10n1p...', constraints: '' },
                'completelink': { type: 'TEXT', length: '200', example: 'https://example.com/complete', constraints: '' },
                'custom_css': { type: 'TEXT', length: '2000', example: '.custom { color: blue; }', constraints: '' },
                'currency_amount': { type: 'REAL', length: '10,2', example: '10.50', constraints: '' },
                
                // Boltz extension fields
                'asset': { type: 'TEXT', length: '20', example: 'BTC/BTC', constraints: 'NN DEF"BTC/BTC"' },
                'direction': { type: 'TEXT', length: '10', example: 'receive', constraints: 'NN DEFreceive' },
                'feerate': { type: 'BOOLEAN', length: '1', example: 'false', constraints: '' },
                'feerate_value': { type: 'INTEGER', length: '4', example: '1', constraints: '' },
                'refund_address': { type: 'TEXT', length: '62', example: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh', constraints: 'NN' },
                'boltz_id': { type: 'TEXT', length: '64', example: 'a1b2c3d4...', constraints: 'NN EXT' },
                'timeout_block_height': { type: 'INTEGER', length: '8', example: '800000', constraints: 'NN' },
                'bip21': { type: 'TEXT', length: '200', example: 'bitcoin:bc1q...?amount=0.001', constraints: '' },
                'redeem_script': { type: 'TEXT', length: '200', example: '522102...', constraints: 'NN' },
                'blinding_key': { type: 'TEXT', length: '64', example: 'a1b2c3d4...', constraints: '' },
                
                // SatsDice extension fields
                'title': { type: 'TEXT', length: '100', example: 'My Dice Game', constraints: 'NN' },
                'haircut': { type: 'REAL', length: '5,2', example: '0.01', constraints: 'NN' },
                'chance': { type: 'REAL', length: '5,2', example: '0.5', constraints: 'NN' },
                'base_url': { type: 'TEXT', length: '200', example: 'https://example.com', constraints: 'NN' },
                'open_time': { type: 'INTEGER', length: '8', example: '1640995200', constraints: 'NN' },
                
                // Coinflip extension fields
                'settings_id': { type: 'TEXT', length: '50', example: 'settings_123', constraints: '' },
                'number_of_players': { type: 'INTEGER', length: '2', example: '0', constraints: 'NN DEF0' },
                'buy_in': { type: 'INTEGER', length: '8', example: '1000', constraints: 'NN DEF0' },
                'players': { type: 'TEXT', length: '1000', example: 'player1,player2', constraints: 'DEF""' },
                'completed': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                'max_players': { type: 'INTEGER', length: '2', example: '5', constraints: 'NN DEF5' },
                'enabled': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                
                // BoltCard Hit and Refund fields
                'card_id': { type: 'TEXT', length: '50', example: 'card_123', constraints: 'NN FK' },
                'ip': { type: 'TEXT', length: '45', example: '192.168.1.1', constraints: '' },
                'spent': { type: 'BOOLEAN', length: '1', example: 'false', constraints: 'DEFfalse' },
                'useragent': { type: 'TEXT', length: '500', example: 'Mozilla/5.0...', constraints: '' },
                'old_ctr': { type: 'INTEGER', length: '8', example: '0', constraints: 'NN DEF0' },
                'new_ctr': { type: 'INTEGER', length: '8', example: '1', constraints: 'NN DEF0' },
                'hit_id': { type: 'TEXT', length: '50', example: 'hit_123', constraints: 'NN FK' },
                'refund_amount': { type: 'INTEGER', length: '8', example: '1000', constraints: 'NN' }
            };

            const info = fieldInfo[fieldName] || { type: dataType, length: '?', example: '...', constraints: '' };
            
            // Format the display string
            let display = info.type;
            if (info.length && info.length !== '?') {
                display += `(${info.length})`;
            }
            if (info.constraints) {
                display += ` ${info.constraints}`;
            }
            
            return display;
        }
        
        function getJsonStructureTooltip(fieldName) {
            const jsonStructures = {
                'extra': '{"icon":"flash_on","color":"primary","theme":"dark"}',
                'meta': '{"version":"1.0","settings":{"auto_update":true}}',
                'webhook_headers': '{"Authorization":"Bearer token","Content-Type":"application/json"}',
                'webhook_body': '{"amount":1000,"memo":"Payment","wallet_id":"abc123"}',
                'card_data': '{"version":"1.0","name":"My Card","settings":{"auto_reload":true}}',
                'custom_css': '{"styles":".custom{color:blue}","theme":"dark"}'
            };
            
            return jsonStructures[fieldName] || '{"key":"value","nested":{"data":"example"}}';
        }

        function estimateTextWidth(text, fontSizePx) {
            const avg = fontSizePx * 0.6; // rough monospace estimate
            return text.length * avg;
        }

        function computeTableWidth(table, minWidth) {
            const leftFont = 10;
            const rightFont = 9;
            let maxLeft = estimateTextWidth('Header', leftFont);
            let maxRight = 0;
            table.fields.forEach((field, i) => {
                // Left side text includes icon and field name
                const icon = (field === 'id' || field === 'checking_id') ? '🔑 ' : ((field === 'wallet' || field === 'user' || field === 'wallet_id' || field === 'access_control_list') ? '🔗 ' : '');
                const left = estimateTextWidth(icon + field, leftFont);
                if (left > maxLeft) maxLeft = left;
                const dtype = (table.datatypes && table.datatypes[i]) ? table.datatypes[i] : 'TEXT';
                const info = getFieldInfo(field, dtype);
                const right = estimateTextWidth(info, rightFont);
                if (right > maxRight) maxRight = right;
            });
            return Math.max(minWidth, 30 + maxLeft + 20 + maxRight + 20);
        }

        function renderSchema() {
            // Prevent multiple simultaneous renders
            if (window.isRendering) {
                console.log('Render already in progress, skipping...');
                return;
            }
            
            // Check if data is loaded
            if (!schemaData) {
                console.log('Schema data not loaded yet, skipping render...');
                return;
            }
            
            window.isRendering = true;
            
            console.log('Starting renderSchema...');
            
            // Clear previous content completely - this is critical for preventing duplicates
            g.selectAll("*").remove();
            
            // Clear any existing FK lines
            clearFkLines();
            
            // Clear any existing relationship lines
            g.selectAll('.core-rel').remove();
            g.selectAll('.fk-rel').remove();
            
            // Clear any existing table groups
            g.selectAll('.table-group').remove();
            
            // Clear any existing tooltips
            d3.selectAll('.tooltip').remove();

            const width = svg.attr("width");
            const height = svg.attr("height");
            const padding = 40; // Padding from edges
            const availableWidth = width - (padding * 2);
            const availableHeight = height - (padding * 2);

            let tableCount = 0;
            let extensionCount = 0;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            // Reset positions maps
            tablePositions = {};
            fieldPositions = {};

            // Get filtered core tables
            const coreTables = schemaData.core.tables.filter(table => {
                if (!searchTerm) return true;
                
                const matchesTable = table.name.toLowerCase().includes(searchTerm);
                const matchesFields = table.fields && table.fields.some(field => field.toLowerCase().includes(searchTerm));
                const matchesDataTypes = table.datatypes && table.datatypes.some(dt => dt.toLowerCase().includes(searchTerm));
                
                // Also check field info constraints (NN, UQ, FK, DEFNOW, etc.)
                const matchesConstraints = table.fields && table.fields.some(field => {
                    const fieldIndex = table.fields.indexOf(field);
                    const dataType = (table.datatypes && table.datatypes[fieldIndex]) || "TEXT";
                    const fieldInfo = getFieldInfo(field, dataType);
                    return fieldInfo.toLowerCase().includes(searchTerm.toLowerCase());
                });
                
                return matchesTable || matchesFields || matchesDataTypes || matchesConstraints;
            });

            // Flexible core table layout with individual headlines like extensions
            if (coreTables.length > 0) {
                // Use same width as extensions for symmetry
                const extensionWidth = Math.max(120, Math.min(200, (availableWidth - (padding * 2)) / 4 - 20)); // Same as extensions
                const coreTableWidth = extensionWidth; // Match extension width
                const tablesPerRow = 5; // Fixed to 5 per row like extensions
                const coreTableSpacing = Math.max(15, (availableWidth - (tablesPerRow * coreTableWidth)) / (tablesPerRow + 1));
                const coreStartX = padding + coreTableSpacing;
                const coreY = padding + 30; // Top area for core tables
                
                // Calculate actual row heights based on table content (including headlines)
                const headlineHeight = 30;
                const headerHeight = 25;
                const rowHeight = 18;
                const coreRowHeights = [];
                for (let i = 0; i < coreTables.length; i += tablesPerRow) {
                    const rowTables = coreTables.slice(i, i + tablesPerRow);
                    const maxHeightInRow = Math.max(...rowTables.map(table => headlineHeight + headerHeight + (table.fields.length * rowHeight)));
                    coreRowHeights.push(maxHeightInRow + 20); // Add spacing between rows
                }
                
            coreTables.forEach((table, i) => {
                    const row = Math.floor(i / tablesPerRow);
                    const col = i % tablesPerRow;
                    const x = coreStartX + (col * (coreTableWidth + coreTableSpacing));
                    
                    // Calculate Y position based on cumulative row heights
                    let y = coreY;
                    for (let r = 0; r < row; r++) {
                        y += coreRowHeights[r];
                    }
                
                    // Create core table group with individual headline like extensions
                const coreGroup = g.append("g")
                    .attr("class", `core-group ${table.name.toLowerCase()}`)
                    .attr("transform", `translate(${x}, ${y})`);

                // Individual headline for each core table (like extensions)
                const headlineWidth = coreTableWidth;
                const headlineHeight = 30;
                const headline = coreGroup.append("rect")
                    .attr("width", headlineWidth)
                    .attr("height", headlineHeight)
                    .attr("rx", 5)
                    .attr("fill", schemaData.core.color)
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1)
                    .style("opacity", 1)
                    .style("filter", "drop-shadow(1px 1px 4px rgba(0,0,0,0.3))");

                coreGroup.append("text")
                    .attr("x", headlineWidth / 2)
                    .attr("y", 15)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .attr("fill", getHighlightedTextColor(searchTerm, "CORE TABLE", "white"))
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .text("CORE TABLE");

                // Render table below headline
                const tableY = 40; // Start position for table below headline
                const tableGroup = coreGroup.append("g")
                    .attr("class", `table-group core-table-group core ${table.name.toLowerCase()}`)
                    .attr("transform", `translate(0, ${tableY})`);

                const tableWidth = Math.min(coreTableWidth, computeTableWidth(table, coreTableWidth));
                const headerHeight = 25;
                const rowHeight = 18;
                const totalHeight = headerHeight + (table.fields.length * rowHeight);

                // Main table rectangle (extension-style: colored header, black body)
                tableGroup.append("rect")
                    .attr("width", tableWidth)
                    .attr("height", totalHeight)
                    .attr("rx", 4)
                    .attr("fill", schemaData.core.color)
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1)
                    .style("opacity", 1.0)
                    .style("filter", "drop-shadow(1px 1px 2px rgba(0,0,0,0.2))");

                // Table header
                tableGroup.append("rect")
                    .attr("width", tableWidth)
                    .attr("height", headerHeight)
                    .attr("rx", 4)
                    .attr("fill", "#fff")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1);

                tableGroup.append("text")
                    .attr("x", tableWidth / 2)
                    .attr("y", headerHeight / 2)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .attr("fill", getHighlightedTextColor(searchTerm, table.name, "#000"))
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .text(table.name);

                // Store table position for relationships (accounting for headline)
                tablePositions[table.name] = {
                    x: x + tableWidth / 2,
                    y: y + headlineHeight + headerHeight / 2,
                    width: tableWidth,
                    height: totalHeight
                };

                // Add black background for table body area
                tableGroup.append("rect")
                    .attr("width", tableWidth)
                    .attr("height", table.fields.length * rowHeight)
                    .attr("y", headerHeight)
                    .attr("fill", "#000")
                    .attr("stroke", "#333");

                // Render fields as table rows
                table.fields.forEach((field, fieldIndex) => {
                    const fieldY = headerHeight + (fieldIndex * rowHeight);

                    // PK/FK indicators
                    let pkFkText = "";
                    let isForeignKey = false;
                    if (field === "id" || field === "checking_id") {
                        pkFkText = "🔑"; // Primary key
                    } else if (field === "wallet" || field === "user" || field === "wallet_id" || field === "access_control_list") {
                        pkFkText = "🔗"; // Foreign key
                        isForeignKey = true;
                    }

                    // Field name with PK/FK indicator
                        const fieldText = tableGroup.append("text")
                        .attr("x", 10)
                        .attr("y", fieldY + rowHeight / 2)
                        .attr("dominant-baseline", "middle")
                            .attr("fill", getHighlightedTextColor(searchTerm, pkFkText + " " + field, "#fff"))
                        .attr("font-size", "10px")
                        .attr("font-family", "monospace")
                        .text(pkFkText + " " + field);

                    // Enhanced data type with length and constraints
                    const dataType = table.datatypes[fieldIndex] || "TEXT";
                    const fieldInfo = getFieldInfo(field, dataType);
                    
                    tableGroup.append("text")
                        .attr("x", tableWidth - 10)
                        .attr("y", fieldY + rowHeight / 2)
                        .attr("text-anchor", "end")
                        .attr("dominant-baseline", "middle")
                            .attr("fill", getHighlightedTextColor(searchTerm, fieldInfo, "#00E676"))
                        .attr("font-size", "9px")
                        .attr("font-family", "monospace")
                        .text(fieldInfo);

                        // Record absolute position for this field (accounting for headline)
                        fieldPositions[`${table.name}.${field}`] = {
                            x: x + 10,
                            y: y + headlineHeight + fieldY + rowHeight / 2
                        };

                        // Tooltip on hover for field
                        fieldText.on("mousemove", (event) => {
                            const tooltip = document.getElementById('tooltip');
                            if (tooltip) {
                                tooltip.style.display = 'block';
                                tooltip.style.left = (event.pageX + 12) + 'px';
                                tooltip.style.top = (event.pageY + 12) + 'px';
                                const fieldData = getFieldInfo(field, dataType);
                                const exampleText = fieldData.example ? `<br/>Example: ${fieldData.example}` : '';
                                tooltip.innerHTML = `<h3>${table.name}.${field}</h3><p class="technical">${fieldInfo}${exampleText}</p>`;
                            }
                        }).on("mouseleave", () => {
                            const tooltip = document.getElementById('tooltip');
                            if (tooltip) {
                                tooltip.style.display = 'none';
                            }
                        });

                        // Click FK to draw line to PK/table
                        if (isForeignKey) {
                            fieldText.style("cursor", "pointer");
                            fieldText.on("click", (event) => {
                                event.stopPropagation();
                                highlightForeignKey(table.name, field);
                            });
                        }
                });

                // Add click handler to core table
                tableGroup.on("click", function() {
                        clearFkLines(); // Clear FK lines when clicking on table
                    highlightDependencies(table.name);
                });

                tableCount++;
            });
            }

            // Get filtered extensions and group by category
            const extensionData = [];
            const categoryGroups = {};
            
            Object.entries(schemaData.extensions).forEach(([extId, ext]) => {
                if (currentFilter !== "all" && ext.category !== currentFilter) {
                    return; // Skip filtered out extensions
                }

                if (searchTerm) {
                    // Search in extension name, table names, field names, categories, and descriptions
                    const matchesExtension = ext.name.toLowerCase().includes(searchTerm) ||
                                          ext.category.toLowerCase().includes(searchTerm) ||
                                          ext.description.toLowerCase().includes(searchTerm);
                    
                    const matchesTables = ext.tables.some(table => 
                        table.name.toLowerCase().includes(searchTerm) ||
                        table.fields.some(field => field.toLowerCase().includes(searchTerm))
                    );
                    
                    // Also check if any field contains the search term (for data types like "TEXT")
                    const matchesDataTypes = ext.tables.some(table => 
                        table.datatypes && table.datatypes.some(dt => dt.toLowerCase().includes(searchTerm))
                    );
                    
                    // Also check field info constraints (NN, UQ, FK, DEFNOW, etc.)
                    const matchesConstraints = ext.tables.some(table => 
                        table.fields && table.fields.some(field => {
                            const fieldIndex = table.fields.indexOf(field);
                            const dataType = (table.datatypes && table.datatypes[fieldIndex]) || "TEXT";
                            const fieldInfo = getFieldInfo(field, dataType);
                            return fieldInfo.toLowerCase().includes(searchTerm.toLowerCase());
                        })
                    );
                    
                    if (!matchesExtension && !matchesTables && !matchesDataTypes && !matchesConstraints) {
                    return; // Skip if doesn't match search
                    }
                }

                // Group by category
                const category = ext.category || 'other';
                if (!categoryGroups[category]) {
                    categoryGroups[category] = [];
                }
                categoryGroups[category].push({ extId, ext });
                extensionCount++;
            });

            // Flatten grouped extensions for rendering (maintaining category grouping)
            Object.keys(categoryGroups).forEach(category => {
                extensionData.push(...categoryGroups[category]);
            });
            console.log('Processing extensions:', extensionData.length, 'extensions found');
            console.log('All extensions:', Object.keys(schemaData.extensions));

            // Flexible extension layout
            if (extensionData.length > 0) {
                // Calculate actual core table bottom position (accounting for headlines and rows)
                let coreBottomY = padding + 30; // coreY position
                if (coreTables.length > 0) {
                    const headlineHeight = 30;
                    const headerHeight = 25;
                    const rowHeight = 18;
                    const tablesPerRow = Math.floor(availableWidth / (Math.min(200, (availableWidth - (padding * 2)) / 4 - 20) + 20));
                    
                    // Calculate cumulative height of all core rows (including headlines)
                    let totalCoreHeight = 0;
                    for (let i = 0; i < coreTables.length; i += tablesPerRow) {
                        const rowTables = coreTables.slice(i, i + tablesPerRow);
                        const maxHeightInRow = Math.max(...rowTables.map(table => headlineHeight + headerHeight + (table.fields.length * rowHeight)));
                        totalCoreHeight += maxHeightInRow + 20; // Add spacing between rows
                    }
                    
                    coreBottomY += totalCoreHeight;
                }
                const gap = 170; // Gap between core tables and extensions
                const extensionAreaY = coreBottomY + gap;
                const availableExtensionHeight = availableHeight - extensionAreaY - padding;
                
                // Calculate optimal columns based on available space
                const minExtensionWidth = 180; // Minimum width per extension
                const maxCols = Math.floor(availableWidth / minExtensionWidth);
                const cols = Math.min(maxCols, 5); // Fixed 5 per row like core tables
                const rows = Math.ceil(extensionData.length / cols);
                
                // Calculate spacing
                const extensionWidth = Math.max(120, Math.min(200, (availableWidth - (padding * 2)) / cols - 20));
                const extensionHeight = Math.min(200, availableExtensionHeight / rows - 20);
                const horizontalSpacing = (availableWidth - (cols * extensionWidth)) / (cols + 1);
                const verticalSpacing = (availableExtensionHeight - (rows * extensionHeight)) / (rows + 1);
                
                const startX = padding + horizontalSpacing;
                const startY = extensionAreaY + verticalSpacing;

                // Calculate actual heights for each extension
                const extensionHeights = extensionData.map(({ ext }) => {
                    const headerHeight = 30; // Extension header height
                    let totalTableHeight = 0;
                    
                    // Calculate height for each table in this extension
                    ext.tables.forEach((table) => {
                        const tableHeaderHeight = 25;
                        const tableRowHeight = 18;
                        const tableHeight = tableHeaderHeight + (table.fields.length * tableRowHeight);
                        totalTableHeight += tableHeight + 15; // Add spacing between tables
                    });
                    
                    return headerHeight + totalTableHeight + 5; // Add small margin at bottom
                });
                
                // Calculate row heights based on tallest extension in each row
                const rowHeights = [];
                let currentY = startY;
                for (let i = 0; i < extensionData.length; i += cols) {
                    const rowExtensions = extensionData.slice(i, i + cols);
                    const maxHeightInRow = Math.max(...rowExtensions.map((_, idx) => extensionHeights[i + idx]));
                    rowHeights.push({ startY: currentY, height: maxHeightInRow });
                    currentY += maxHeightInRow + verticalSpacing;
                }

                console.log('Rendering extensions:', extensionData.length, 'extensions');
            extensionData.forEach(({ extId, ext }, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                    const x = startX + (col * (extensionWidth + horizontalSpacing));
                    const y = rowHeights[row].startY;
                    console.log('Rendering extension', index + 1, ':', extId, 'at position', x, y);
                    
                    // Use actual calculated height for this extension
                    const dynamicHeight = extensionHeights[index];

                // Extension group
                const extGroup = g.append("g")
                    .attr("class", `extension-group ${extId}`)
                        .attr("data-extension-id", extId)
                    .attr("transform", `translate(${x}, ${y})`);

                // Extension header
                    const headerWidth = extensionWidth;
                    const extHeader = extGroup.append("rect")
                        .attr("width", headerWidth)
                    .attr("height", 30)
                    .attr("rx", 5)
                    .attr("fill", ext.color)
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1)
                    .style("opacity", 1)
                    .style("filter", "drop-shadow(1px 1px 4px rgba(0,0,0,0.3))");

                extGroup.append("text")
                        .attr("x", headerWidth / 2)
                    .attr("y", 15)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                        .attr("fill", getHighlightedTextColor(searchTerm, ext.name, "white"))
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .text(ext.name);

                    // Link icon to GitHub if available
                    if (ext.github) {
                        extGroup.append("text")
                            .attr("x", headerWidth - 15)
                            .attr("y", 15)
                            .attr("text-anchor", "middle")
                            .attr("dominant-baseline", "middle")
                            .attr("fill", "#ffffff")
                            .attr("font-size", "12px")
                            .style("cursor", "pointer")
                            .text("↗")
                            .on("click", () => window.open(ext.github, '_blank'))
                            .append("title").text("Open GitHub");
                    }

                // Render extension tables with actual table format
                    let cumulativeY = 40; // Start position for first table
                ext.tables.forEach((table, i) => {
                        const tableX = 10; // Small margin from extension edge
                        const tableY = cumulativeY;
                    
                    const tableGroup = extGroup.append("g")
                            .attr("class", `table-group extension-table-group extension ${extId}`)
                            .attr("data-extension-id", extId)
                        .attr("transform", `translate(${tableX}, ${tableY})`);

                        const tableWidth = Math.min(extensionWidth - 20, computeTableWidth(table, extensionWidth - 20));
                    const headerHeight = 25;
                    const rowHeight = 18;
                    const totalHeight = headerHeight + (table.fields.length * rowHeight);

                        // Main table rectangle (extension tables: colored header, black body)
                    tableGroup.append("rect")
                        .attr("width", tableWidth)
                        .attr("height", totalHeight)
                        .attr("rx", 4)
                        .attr("fill", ext.color)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 1)
                            .style("opacity", 1.0) // Full opacity for extensions
                        .style("filter", "drop-shadow(1px 1px 2px rgba(0,0,0,0.2))");

                    // Table header
                    tableGroup.append("rect")
                        .attr("width", tableWidth)
                        .attr("height", headerHeight)
                        .attr("rx", 4)
                        .attr("fill", "#fff")
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 1);

                    tableGroup.append("text")
                        .attr("x", tableWidth / 2)
                        .attr("y", headerHeight / 2)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                            .attr("fill", getHighlightedTextColor(searchTerm, table.name, "#000"))
                        .attr("font-size", "10px")
                        .attr("font-weight", "bold")
                        .text(table.name);

                        // Add black background for table body area
                        tableGroup.append("rect")
                            .attr("width", tableWidth)
                            .attr("height", table.fields.length * rowHeight)
                            .attr("y", headerHeight)
                            .attr("fill", "#000")
                            .attr("stroke", "#333");

                    // Render fields as table rows
                    table.fields.forEach((field, fieldIndex) => {
                        const fieldY = headerHeight + (fieldIndex * rowHeight);

                        // PK/FK indicators
                        let pkFkText = "";
                            let isForeignKey = false;
                        if (field === "id") {
                            pkFkText = "🔑"; // Primary key
                            } else if (field === "wallet" || field === "user" || field.endsWith('_id') || field === 'payment_hash' || field === 'charge_id') {
                            pkFkText = "🔗"; // Foreign key
                                isForeignKey = true;
                        }

                        // Field name with PK/FK indicator
                            const fieldText = tableGroup.append("text")
                            .attr("x", 8)
                            .attr("y", fieldY + rowHeight / 2)
                            .attr("dominant-baseline", "middle")
                                .attr("fill", getHighlightedTextColor(searchTerm, pkFkText + " " + field, "#fff"))
                            .attr("font-size", "9px")
                            .attr("font-family", "monospace")
                            .text(pkFkText + " " + field);

                            // Enhanced data type with length and constraints (same as core tables)
                        const dataType = table.datatypes[fieldIndex] || "TEXT";
                            const fieldInfo = getFieldInfo(field, dataType);
                            
                        tableGroup.append("text")
                            .attr("x", tableWidth - 8)
                            .attr("y", fieldY + rowHeight / 2)
                            .attr("text-anchor", "end")
                            .attr("dominant-baseline", "middle")
                                .attr("fill", getHighlightedTextColor(searchTerm, fieldInfo, "#00E676"))
                            .attr("font-size", "8px")
                            .attr("font-family", "monospace")
                                .text(fieldInfo);

                            // Record absolute position for this field
                            fieldPositions[`${table.name}.${field}`] = {
                                x: x + tableX + 8,
                                y: y + tableY + fieldY + rowHeight / 2
                            };

                            // Tooltip on hover for field
                            fieldText.on("mousemove", (event) => {
                                const tooltip = document.getElementById('tooltip');
                                if (tooltip) {
                                    tooltip.style.display = 'block';
                                    tooltip.style.left = (event.pageX + 12) + 'px';
                                    tooltip.style.top = (event.pageY + 12) + 'px';
                                    const fieldData = getFieldInfo(field, dataType);
                                    const exampleText = fieldData.example ? `<br/>Example: ${fieldData.example}` : '';
                                    tooltip.innerHTML = `<h3>${table.name}.${field}</h3><p class=\"technical\">${fieldData}${exampleText}</p>`;
                                }
                            }).on("mouseleave", () => {
                                const tooltip = document.getElementById('tooltip');
                                if (tooltip) {
                                    tooltip.style.display = 'none';
                                }
                            });

                            if (isForeignKey) {
                                fieldText.style("cursor", "pointer");
                                fieldText.on("click", (event) => {
                                    event.stopPropagation();
                                    highlightForeignKey(table.name, field);
                                });
                            }
                    });

                    tableCount++;
                        
                        // Update cumulative Y position for next table
                        cumulativeY += totalHeight + 15; // Add table height plus spacing
                    });
                });
            }

            // Add click handlers after all extensions are rendered
            // Single click handler for extension tables that calls highlightDependencies
            g.selectAll(".extension-table-group").on("click", function() {
                clearFkLines(); // Clear FK lines when clicking on table
                const tableName = d3.select(this).select("text").text() || d3.select(this).select("text").node()?.textContent || "";
                const extId = d3.select(this).attr("data-extension-id");
                console.log('Extension table clicked:', {tableName, extId});
                if (typeof highlightDependencies === 'function' && tableName) {
                    highlightDependencies(tableName, extId);
                }
            });


            // Stats removed as requested
            
            // Initialize all tables to full opacity
            initializeTableOpacity();
            
            // Reset rendering flag
            window.isRendering = false;
            console.log('RenderSchema completed');
        }

        // Fit the graph content into the visible SVG area and center it
        function fitToContent(padding = 20) {
            if (!svg || !g) return;
            try {
                const bbox = g.node().getBBox();
                if (!bbox || bbox.width === 0 || bbox.height === 0) return;

                const container = document.getElementById('schemaContainer');
                const rect = container.getBoundingClientRect();
                const cw = rect.width;
                const ch = rect.height;

                const maxScale = 3; // Reduced max scale for better readability
                const minScale = 0.2; // Increased min scale
                const scale = Math.max(minScale, Math.min(maxScale, Math.min(
                    (cw - padding * 2) / bbox.width,
                    (ch - padding * 2) / bbox.height
                )));

                const tx = (cw / 2) - scale * (bbox.x + bbox.width / 2);
                const ty = (ch / 2) - scale * (bbox.y + bbox.height / 2);

                const transform = d3.zoomIdentity.translate(tx, ty).scale(scale);
                svg.transition().duration(500).call(zoom.transform, transform);
            } catch (e) {
                console.warn('fitToContent failed:', e);
            }
        }

        function fitToTopRows(padding = 20) {
            if (!svg || !g) return;
            try {
                // Get the full bounding box first
                const fullBbox = g.node().getBBox();
                if (!fullBbox || fullBbox.width === 0 || fullBbox.height === 0) {
                    fitToContent(padding);
                    return;
                }

                // Calculate approximate height for core tables + first row of extensions
                // Core tables: ~2 rows, Extensions: ~1 row (but show more to cut off first extension row)
                const estimatedRows = 3.5; // Show 3.5 rows to cut off first extension row
                const estimatedRowHeight = 200; // Approximate height per row
                const targetHeight = estimatedRows * estimatedRowHeight;
                
                // Use full width but limit height to top rows
                const targetWidth = fullBbox.width;
                const targetY = fullBbox.y;
                const targetMaxY = Math.min(fullBbox.y + targetHeight, fullBbox.y + fullBbox.height);

                const container = document.getElementById('schemaContainer');
                const rect = container.getBoundingClientRect();
                const cw = rect.width;
                const ch = rect.height;

                const scale = Math.min(
                    (cw - padding * 2) / targetWidth,
                    (ch - padding * 2) / (targetMaxY - targetY)
                );

                // Center horizontally, position vertically to show top rows
                const centerX = fullBbox.x + targetWidth / 2;
                const centerY = targetY + (targetMaxY - targetY) / 2;
                
                const tx = (cw / 2) - scale * centerX;
                const ty = (ch / 2) - scale * centerY;

                const transform = d3.zoomIdentity.translate(tx, ty).scale(scale);
                svg.transition().duration(500).call(zoom.transform, transform);
            } catch (e) {
                console.warn('fitToTopRows failed:', e);
                fitToContent(padding); // Fallback
            }
        }

        function highlightDependencies(tableName, extensionId = null) {
            console.log('highlightDependencies called with:', {tableName, extensionId});
            
            // Safety check
            if (!g) {
                console.log('Debug: g is undefined in highlightDependencies');
                return;
            }
            
            // Reset all highlights - both core and extension tables
            g.selectAll(".table-group").style("opacity", 0.3);
            g.selectAll(".extension-table-group").style("opacity", 0.3);
            g.selectAll("line").style("opacity", 0.1);
            g.selectAll("polygon").style("opacity", 0.1);

            // Highlight clicked table (check both core and extension tables)
            g.selectAll(`.table-group`).each(function() {
                const group = d3.select(this);
                const text = group.select("text");
                if (text.text() === tableName) {
                    group.style("opacity", 1);
                }
            });
            
            g.selectAll(`.extension-table-group`).each(function() {
                const group = d3.select(this);
                const text = group.select("text");
                if (text.text() === tableName) {
                    group.style("opacity", 1);
                }
            });

            selectedTable = tableName;

            // Show dependency info modal
            showDependencyInfo(tableName, extensionId);

            // Define relationships for highlighting (BOTH DIRECTIONS)
            const relationships = {
                'Account': ['Wallet'],
                'Wallet': ['Account', 'Payment', 'PayLink', 'WithdrawLink', 'Card', 'Hit', 'Refund', 'Charge', 'SatsPayPayment', 'SubmarineSwap', 'WalletAccount', 'NostrProduct', 'NostrOrder', 'NostrRelay', 'NostrClient', 'NostrNip5', 'SatsdiceLink', 'SatsDiceBet', 'CoinflipSettings', 'Coinflip', 'NumbersGame', 'NumbersBet', 'EightballGame', 'EightballResponse', 'Event', 'EventTicket', 'Invoice', 'InvoicePayment', 'Paywall', 'PaywallAccess', 'BitcoinSwitch', 'SwitchAction', 'LNURLDevice', 'TipJar', 'Tip', 'StreamAlert', 'CopilotAlert'],
                'Payment': ['Wallet'],
                'AccessControlList': ['UserAcls'],
                'UserAcls': ['AccessControlList'],
                'TinyURL': ['Wallet'],
                'WebPushSubscription': ['Account'],
                'PayLink': ['Wallet'],
                'WithdrawLink': ['Wallet'],
                'Card': ['Wallet', 'Hit'],
                'Hit': ['Card', 'Refund'],
                'Refund': ['Hit'],
                'Charge': ['Account', 'SatsPayPayment'],
                'SatsPayPayment': ['Charge'],
                'SubmarineSwap': ['Wallet'],
                'WalletAccount': ['Account'],
                'NostrProduct': ['Wallet', 'NostrOrder'],
                'NostrOrder': ['NostrProduct'],
                'NostrRelay': ['Wallet'],
                'NostrClient': ['Wallet'],
                'NostrNip5': ['Wallet'],
                'SatsdiceLink': ['Wallet', 'SatsDiceBet'],
                'SatsDiceBet': ['SatsdiceLink'],
                'CoinflipSettings': ['Wallet', 'Coinflip'],
                'Coinflip': ['CoinflipSettings'],
                'NumbersGame': ['Wallet', 'NumbersBet'],
                'NumbersBet': ['NumbersGame'],
                'EightballGame': ['Wallet', 'EightballResponse'],
                'EightballResponse': ['EightballGame'],
                'Event': ['Wallet', 'EventTicket'],
                'EventTicket': ['Event'],
                'Invoice': ['Wallet', 'InvoicePayment'],
                'InvoicePayment': ['Invoice'],
                'Paywall': ['Wallet', 'PaywallAccess'],
                'PaywallAccess': ['Paywall'],
                'BitcoinSwitch': ['Wallet', 'SwitchAction'],
                'SwitchAction': ['BitcoinSwitch'],
                'LNURLDevice': ['Wallet'],
                'TipJar': ['Wallet', 'Tip'],
                'Tip': ['TipJar'],
                'StreamAlert': ['Wallet'],
                'CopilotAlert': ['Wallet'],
                // Extension-to-Extension relationships
                'SatsPayPayment': ['Charge', 'BtcAddress'], // SatsPay can use onchain addresses
                'BtcAddress': ['SatsPayPayment'], // Onchain addresses used by SatsPay
                'NostrProduct': ['NostrOrder', 'BtcAddress'], // Nostr products can have onchain addresses
                'NostrOrder': ['NostrProduct', 'BtcAddress'], // Nostr orders can use onchain addresses
                'BtcAddress': ['NostrProduct', 'NostrOrder'], // Onchain addresses used by Nostr
                'Event': ['EventTicket', 'PayLink'], // Events can use PayLinks
                'EventTicket': ['Event', 'PayLink'], // Event tickets can use PayLinks
                'PayLink': ['Event', 'EventTicket'], // PayLinks can be used by Events
                'Invoice': ['InvoicePayment', 'PayLink'], // Invoices can use PayLinks
                'InvoicePayment': ['Invoice', 'PayLink'], // Invoice payments can use PayLinks
                'PayLink': ['Invoice', 'InvoicePayment'], // PayLinks can be used by Invoices
                'Paywall': ['PaywallAccess', 'PayLink'], // Paywalls can use PayLinks
                'PaywallAccess': ['Paywall', 'PayLink'], // Paywall access can use PayLinks
                'PayLink': ['Paywall', 'PaywallAccess'], // PayLinks can be used by Paywalls
                'TipJar': ['Tip', 'PayLink'], // TipJars can use PayLinks
                'Tip': ['TipJar', 'PayLink'], // Tips can use PayLinks
                'PayLink': ['TipJar', 'Tip'], // PayLinks can be used by TipJar
                'StreamAlert': ['PayLink'], // StreamAlerts can use PayLinks
                'PayLink': ['StreamAlert'], // PayLinks can be used by StreamAlerts
                'CopilotAlert': ['PayLink'], // CopilotAlerts can use PayLinks
                'PayLink': ['CopilotAlert'], // PayLinks can be used by CopilotAlerts
                'BitcoinSwitch': ['SwitchAction', 'BtcAddress'], // BitcoinSwitch can use onchain addresses
                'SwitchAction': ['BitcoinSwitch', 'BtcAddress'], // SwitchActions can use onchain addresses
                'BtcAddress': ['BitcoinSwitch', 'SwitchAction'], // Onchain addresses used by BitcoinSwitch
                'LNURLDevice': ['BtcAddress'], // LNURL devices can have onchain addresses
                'BtcAddress': ['LNURLDevice'], // Onchain addresses used by LNURL devices
                'WatchOnlyWallet': ['BtcAddress'], // Watch-only wallets monitor onchain addresses
                'BtcAddress': ['WatchOnlyWallet'], // Onchain addresses monitored by watch-only wallets
                'SubmarineSwap': ['BtcAddress'], // Submarine swaps can use onchain addresses
                'BtcAddress': ['SubmarineSwap'], // Onchain addresses used by submarine swaps
                'BoltzSwap': ['BtcAddress'], // Boltz swaps can use onchain addresses
                'BtcAddress': ['BoltzSwap'] // Onchain addresses used by Boltz swaps
            };

            // Get related tables (BOTH directions)
            const relatedTables = relationships[tableName] || [];
            
            // Also find tables that depend on this one (reverse lookup)
            const dependedByTables = [];
            Object.entries(relationships).forEach(([table, deps]) => {
                if (deps.includes(tableName)) {
                    dependedByTables.push(table);
                }
            });
            
            // Combine both directions
            const allRelatedTables = [...new Set([...relatedTables, ...dependedByTables])];
            
            console.log(`Highlighting ${tableName}:`, {
                dependsOn: relatedTables,
                dependedBy: dependedByTables,
                allRelated: allRelatedTables
            });

            // Highlight related tables (both core and extension)
            allRelatedTables.forEach(relatedTable => {
                g.selectAll(`.table-group`).each(function() {
                    const group = d3.select(this);
                    const text = group.select("text");
                    if (text.text() === relatedTable) {
                        group.style("opacity", 0.8);
                    }
                });
                
                g.selectAll(`.extension-table-group`).each(function() {
                    const group = d3.select(this);
                    const text = group.select("text");
                    if (text.text() === relatedTable) {
                        group.style("opacity", 0.8);
                    }
                });
            });

            // Highlight relationship lines
            g.selectAll("line").style("opacity", function() {
                const line = d3.select(this);
                // Simple heuristic: if line connects to highlighted tables, make it visible
                return 0.7;
            });
        }

        function highlightExtension(extensionId) {
            // Reset all highlights
            g.selectAll(".table-group").style("opacity", 0.3);
            g.selectAll("line").style("opacity", 0.1);

            // Highlight the selected extension tables
            g.selectAll(`.extension-group.${extensionId} .table-group`).style("opacity", 1);
            
            // Find dependent extensions and highlight them
            const extensionDependencies = {
                'satsPay': ['boltCards', 'payLinks'],
                'boltCards': ['payLinks'],
                'payLinks': ['boltCards'],
                'withdrawLinks': ['payLinks'],
                'events': ['payLinks'],
                'magic8ball': ['payLinks'],
                'nostr': ['payLinks'],
                'boltz': ['payLinks']
            };
            
            const dependentExtensions = extensionDependencies[extensionId] || [];
            
            // Highlight dependent extensions
            dependentExtensions.forEach(depId => {
                g.selectAll(`.extension-group.${depId} .table-group`).style("opacity", 1);
            });

            // Highlight dependency lines
            g.selectAll("line").style("opacity", 0.6);
        }

        function mapForeignKeyToTable(fieldName) {
            const directMap = {
                'wallet': 'Wallet',
                'wallet_id': 'Wallet',
                'user': 'Account',
                'access_control_list': 'AccessControlList',
                'payment_hash': 'Payment',
                'invoice_id': 'Invoice',
                'event_id': 'Event',
                'paywall_id': 'Paywall',
                'switch_id': 'BitcoinSwitch',
                'tipjar_id': 'TipJar',
                'product_id': 'NostrProduct',
                'charge_id': 'SatsPayCharge',
                'game_id': 'SatsDiceGame'
            };
            if (directMap[fieldName]) return directMap[fieldName];
            if (fieldName.endsWith('_id')) {
                const base = fieldName.replace(/_id$/, '');
                // Try to find a table with matching name (case-insensitive)
                const allTables = [
                    ...schemaData.core.tables.map(t => t.name),
                    ...Object.values(schemaData.extensions).flatMap(ext => ext.tables.map(t => t.name))
                ];
                const found = allTables.find(t => t.toLowerCase() === base.toLowerCase());
                if (found) return found;
            }
            return null;
        }

        function clearFkLines() {
            g.selectAll('.fk-rel').remove();
        }

        function highlightForeignKey(tableName, fieldName) {
            clearFkLines();
            const source = fieldPositions[`${tableName}.${fieldName}`];
            const targetTableName = mapForeignKeyToTable(fieldName);
            if (!source || !targetTableName) return;
            
            // Find the primary key field in the target table
            let targetField = null;
            const targetTable = schemaData.core.tables.find(t => t.name === targetTableName) ||
                               schemaData.extensions.flatMap(ext => ext.ext.tables).find(t => t.name === targetTableName);
            
            if (targetTable && targetTable.fields) {
                const pkField = targetTable.fields.find(field => field.pk);
                if (pkField) {
                    targetField = fieldPositions[`${targetTableName}.${pkField.name}`];
                }
            }
            
            // If no specific PK field found, use table center
            const target = targetField || tablePositions[targetTableName];
            if (!target) return;

            const toX = target.x;
            const toY = target.y;

            g.append('line')
                .attr('x1', source.x)
                .attr('y1', source.y)
                .attr('x2', toX)
                .attr('y2', toY)
                .attr('stroke', '#00FF00')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('class', 'fk-rel');
        }

        function showTableDetails(table, type, extension = null) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 2000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 10px;
                padding: 2rem;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                color: #e0e0e0;
            `;

            let fieldsTable = '';
            if (table.fields && table.fields.length > 0) {
                fieldsTable = `
                    <h3>Table Fields</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                        <thead>
                            <tr style="background: #333;">
                                <th style="padding: 0.5rem; border: 1px solid #444; text-align: left;">Field Name</th>
                                <th style="padding: 0.5rem; border: 1px solid #444; text-align: left;">Data Type</th>
                                <th style="padding: 0.5rem; border: 1px solid #444; text-align: left;">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${table.fields.map((field, i) => `
                                <tr style="background: ${i % 2 === 0 ? '#2a2a2a' : '#1a1a1a'};">
                                    <td style="padding: 0.5rem; border: 1px solid #444; font-family: monospace;">${field}</td>
                                    <td style="padding: 0.5rem; border: 1px solid #444; color: #4CAF50; font-family: monospace;">${table.datatypes[i] || 'TEXT'}</td>
                                    <td style="padding: 0.5rem; border: 1px solid #444;">${getFieldDescription(field, table.name)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }

            let extensionInfo = '';
            if (extension) {
                extensionInfo = `
                    <div style="margin-top: 1rem; padding: 1rem; background: #2a2a2a; border-radius: 5px;">
                        <h4>Extension Information</h4>
                        <p><strong>Name:</strong> ${extension.name}</p>
                        <p><strong>Category:</strong> ${extension.category}</p>
                        <p><strong>Description:</strong> ${extension.description}</p>
                        <p><strong>Technical:</strong> ${extension.technical}</p>
                        ${extension.github ? `<p><strong>GitHub:</strong> <a href="${extension.github}" target="_blank" style="color: #4CAF50;">${extension.github}</a></p>` : ''}
                    </div>
                `;
            }

            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h2 style="color: #667eea; margin: 0;">${table.name}</h2>
                    <button onclick="this.closest('.modal-overlay').remove()" style="background: #dc3545; color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer;">Close</button>
                </div>
                
                <div style="margin-bottom: 1rem;">
                    <p><strong>Type:</strong> ${type === 'core' ? 'Core LNbits Table' : 'Extension Table'}</p>
                    <p><strong>Description:</strong> ${table.description}</p>
                    <p><strong>Technical Details:</strong> ${table.technical}</p>
                </div>

                ${fieldsTable}
                ${extensionInfo}
            `;

            modal.className = 'modal-overlay';
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close on click outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        function getFieldDescription(fieldName, tableName) {
            const descriptions = {
                'id': 'Primary key identifier',
                'wallet': 'Foreign key reference to Wallet table',
                'user': 'Foreign key reference to Account table',
                'payment_hash': 'Lightning payment hash',
                'amount': 'Amount in millisatoshis',
                'fee': 'Transaction fee in millisatoshis',
                'bolt11': 'Lightning invoice (BOLT11)',
                'status': 'Payment status',
                'memo': 'Payment memo/description',
                'time': 'Timestamp of the event',
                'created_at': 'Record creation timestamp',
                'updated_at': 'Record last update timestamp',
                'active': 'Whether the record is active',
                'name': 'Display name',
                'description': 'Description text',
                'price': 'Price in millisatoshis',
                'currency': 'Currency code',
                'webhook_url': 'Webhook URL for notifications',
                'username': 'Username for Lightning Address',
                'min': 'Minimum payment amount',
                'max': 'Maximum payment amount'
            };
            return descriptions[fieldName] || 'Field description not available';
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // Event listeners
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentFilter = this.dataset.filter;
                renderSchema();
                setTimeout(() => fitToContent(20), 0);
            });
        });


        document.getElementById('searchInput').addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            const clearButton = document.getElementById('searchClear');
            
            // Show/hide clear button based on input
            if (searchTerm.length > 0) {
                clearButton.style.display = 'flex';
            } else {
                clearButton.style.display = 'none';
            }
            
            // Trigger re-render with search filter
            renderSchema();
        });

        // Clear button functionality
        document.getElementById('searchClear').addEventListener('click', function() {
            const searchInput = document.getElementById('searchInput');
            searchInput.value = '';
            this.style.display = 'none';
            renderSchema();
        });

        // Zoom controls - use D3's default behavior without custom re-rendering
        document.getElementById('zoomIn').addEventListener('click', function() {
            svg.transition().call(zoom.scaleBy, 1.5);
        });

        document.getElementById('zoomOut').addEventListener('click', function() {
            svg.transition().call(zoom.scaleBy, 1 / 1.5);
        });

        document.getElementById('resetZoom').addEventListener('click', function() {
                fitToContent(20);
            resetHighlights();
        });

        function resetHighlights() {
            g.selectAll(".table-group").style("opacity", 1);
            g.selectAll("line").style("opacity", 0.6);
            selectedTable = null;
            clearFkLines();
            hideDependencyInfo();
        }

        function initializeTableOpacity() {
            // Set all tables to full opacity initially
            g.selectAll(".table-group").style("opacity", 1);
        }

        function setupSvgClickHandler() {
        // Add click handler to reset highlights when clicking on empty space
        svg.on("click", function(event) {
                // Check if click is on empty space (not on tables or other elements)
                if (event.target === svg.node() || event.target.tagName === 'svg') {
                resetHighlights();
                    clearFkLines(); // Clear FK lines when clicking empty space
                }
            });
        }


        // Initialize legend toggle functionality
        function initLegendToggle() {
            const toggleBtn = document.getElementById('toggleLegend');
            const legend = document.getElementById('legend-explanations');
            
            if (toggleBtn && legend) {
                console.log('Legend toggle initialized');
                toggleBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    console.log('Legend button clicked');
                    
                    // Force show the legend modal
                    if (legend.style.display === 'none' || legend.style.display === '') {
                        legend.style.display = 'block';
                        legend.style.visibility = 'visible';
                        legend.style.opacity = '1';
                        console.log('Legend shown');
                    } else {
                        legend.style.display = 'none';
                        legend.style.visibility = 'hidden';
                        legend.style.opacity = '0';
                        console.log('Legend hidden');
                    }
                });
            } else {
                console.log('Legend elements not found:', {toggleBtn, legend});
            }
        }

        // Dependency Analysis Functions
        function analyzeExtensionDependencies() {
            if (!schemaData) return;
            
            const dependencies = {
                core: {},
                extensionToExtension: {},
                all: {}
            };
            
            // Analyze core dependencies
            Object.entries(schemaData.extensions).forEach(([extId, ext]) => {
                if (ext.dependencies && ext.dependencies.length > 0) {
                    dependencies.core[extId] = {
                        name: ext.name,
                        category: ext.category,
                        description: ext.description,
                        dependencies: ext.dependencies,
                        color: ext.color
                    };
                }
            });
            
            // Analyze extension-to-extension dependencies
            Object.entries(schemaData.extensions).forEach(([extId, ext]) => {
                dependencies.extensionToExtension[extId] = {
                    name: ext.name,
                    category: ext.category,
                    description: ext.description,
                    color: ext.color,
                    dependsOn: [],
                    dependedBy: []
                };
            });
            
            // Find extension-to-extension relationships
            Object.entries(schemaData.extensions).forEach(([extId, ext]) => {
                ext.tables.forEach(table => {
                    table.fields.forEach(field => {
                        // Check if field references another extension's table
                        Object.entries(schemaData.extensions).forEach(([otherExtId, otherExt]) => {
                            if (extId !== otherExtId) {
                                otherExt.tables.forEach(otherTable => {
                                    if (field === otherTable.name.toLowerCase() + '_id' || 
                                        field === otherTable.name.toLowerCase() ||
                                        field.includes(otherTable.name.toLowerCase())) {
                                        dependencies.extensionToExtension[extId].dependsOn.push({
                                            extension: otherExtId,
                                            name: otherExt.name,
                                            table: otherTable.name,
                                            field: field
                                        });
                                        dependencies.extensionToExtension[otherExtId].dependedBy.push({
                                            extension: extId,
                                            name: ext.name,
                                            table: table.name,
                                            field: field
                                        });
                                    }
                                });
                            }
                        });
                    });
                });
            });
            
            // Combine all dependencies
            dependencies.all = { ...dependencies.core, ...dependencies.extensionToExtension };
            
            return dependencies;
        }
        
        function renderDependencyAnalysis(type = 'all') {
            const dependencies = analyzeExtensionDependencies();
            const content = document.getElementById('dependencyContent');
            
            if (!content) return;
            
            let html = '<div class="dependency-graph">';
            
            if (type === 'all' || type === 'core') {
                html += '<div class="dependency-group">';
                html += '<h3>🔗 Core Dependencies</h3>';
                html += '<div class="dependency-list">';
                
                Object.entries(dependencies.core).forEach(([extId, ext]) => {
                    html += `
                        <div class="dependency-item">
                            <strong>${ext.name}</strong>
                            <div class="category">${ext.category}</div>
                            <div class="description">${ext.description}</div>
                            <div style="margin-top: 0.5rem;">
                                <strong>Depends on:</strong> ${ext.dependencies.join(', ')}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            }
            
            if (type === 'all' || type === 'extension') {
                html += '<div class="dependency-group">';
                html += '<h3>🔗 Extension-to-Extension Dependencies</h3>';
                html += '<div class="dependency-list">';
                
                Object.entries(dependencies.extensionToExtension).forEach(([extId, ext]) => {
                    if (ext.dependsOn.length > 0 || ext.dependedBy.length > 0) {
                        html += `
                            <div class="dependency-item">
                                <strong>${ext.name}</strong>
                                <div class="category">${ext.category}</div>
                                <div class="description">${ext.description}</div>
                        `;
                        
                        if (ext.dependsOn.length > 0) {
                            html += '<div style="margin-top: 0.5rem;"><strong>Depends on:</strong><ul>';
                            ext.dependsOn.forEach(dep => {
                                html += `<li>${dep.name} (${dep.table}.${dep.field})</li>`;
                            });
                            html += '</ul></div>';
                        }
                        
                        if (ext.dependedBy.length > 0) {
                            html += '<div style="margin-top: 0.5rem;"><strong>Depended by:</strong><ul>';
                            ext.dependedBy.forEach(dep => {
                                html += `<li>${dep.name} (${dep.table}.${dep.field})</li>`;
                            });
                            html += '</ul></div>';
                        }
                        
                        html += '</div>';
                    }
                });
                
                html += '</div></div>';
            }
            
            html += '</div>';
            content.innerHTML = html;
        }
        
        function openDependencyModal() {
            console.log('openDependencyModal called');
            const modal = document.getElementById('dependencyModal');
            if (modal) {
                console.log('Modal found, showing...');
                modal.style.display = 'flex';
                renderDependencyAnalysis('all');
            } else {
                console.log('Modal not found!');
            }
        }
        
        function closeDependencyModal() {
            const modal = document.getElementById('dependencyModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function showDependencyInfo(tableName, extensionId = null) {
            const modal = document.getElementById('dependencyInfoModal');
            const content = document.getElementById('dependencyInfoContent');
            
            if (!modal || !content) return;
            
            // Hide legend if it's open
            const legend = document.getElementById('legend-explanations');
            if (legend) {
                legend.style.display = 'none';
            }
            
            // Find table info
            let tableInfo = null;
            let extensionInfo = null;
            
            // Check core tables first
            if (schemaData && schemaData.core && schemaData.core.tables) {
                tableInfo = schemaData.core.tables.find(t => t.name === tableName);
                if (tableInfo) {
                    extensionInfo = { name: 'Core LNbits', category: 'core', color: '#FF1493' };
                }
            }
            
            // Check extension tables
            if (!tableInfo && schemaData && schemaData.extensions) {
                Object.entries(schemaData.extensions).forEach(([extId, ext]) => {
                    if (ext.tables) {
                        const foundTable = ext.tables.find(t => t.name === tableName);
                        if (foundTable) {
                            tableInfo = foundTable;
                            extensionInfo = ext;
                        }
                    }
                });
            }
            
            if (!tableInfo) {
                modal.style.display = 'none';
                return;
            }
            
            // Generate dependency info
            let html = '';
            
            // Table basic info
            html += `
                <div class="dependency-info-item">
                    <strong>${tableInfo.name}</strong>
                    <div class="category">${extensionInfo.category}</div>
                    <div class="description">${tableInfo.description}</div>
                    <div class="relationships">
                        <strong>Technical:</strong> ${tableInfo.technical}
                    </div>
                </div>
            `;
            
            // Find related tables
            const relatedTables = findRelatedTables(tableName, extensionId);
            
             if (relatedTables.dependsOn.length > 0) {
                 html += `
                     <div class="dependency-info-item">
                         <strong>📥 Uses Data From:</strong>
                         <ul>
                             ${relatedTables.dependsOn.map(table => `<li>${table.toLowerCase()} → ${table.toLowerCase()}.id</li>`).join('')}
                         </ul>
                     </div>
                 `;
             }
             
             if (relatedTables.dependedBy.length > 0) {
                 html += `
                     <div class="dependency-info-item">
                         <strong>📤 Provides Data To:</strong>
                         <ul>
                             ${relatedTables.dependedBy.map(table => `<li>${table.toLowerCase()} → ${table.toLowerCase()}.id</li>`).join('')}
                         </ul>
                     </div>
                 `;
             }
            
            // Show foreign key relationships
            if (tableInfo.fields) {
                const fkFields = tableInfo.fields.filter(field => 
                    field === 'wallet' || field === 'user' || field === 'wallet_id' || 
                    field.endsWith('_id') || field === 'access_control_list'
                );
                
                 if (fkFields.length > 0) {
                     html += `
                         <div class="dependency-info-item">
                             <strong>🔗 Foreign Key Fields:</strong>
                             <ul>
                                 ${fkFields.map(field => {
                                     // Determine target table.column for clearer display
                                     let targetTable = '';
                                     if (field === 'wallet' || field === 'wallet_id') {
                                         targetTable = ' → wallet.id';
                                     } else if (field === 'user') {
                                         targetTable = ' → account.id';
                                     } else if (field === 'access_control_list') {
                                         targetTable = ' → access_control_list.id';
                                     } else if (field.endsWith('_id')) {
                                         const baseName = field.replace('_id', '');
                                         targetTable = ` → ${baseName}.id`;
                                     } else {
                                         targetTable = ' → external';
                                     }
                                     return `<li>${field}${targetTable}</li>`;
                                 }).join('')}
                             </ul>
                         </div>
                     `;
                 }
            }
            
            content.innerHTML = html;
            modal.style.display = 'block';
        }
        
        function findRelatedTables(tableName, extensionId = null) {
            const dependsOn = [];
            const dependedBy = [];
            
            // Define relationships based on table name
            const relationships = {
                'Account': ['Wallet'],
                'Wallet': ['Account', 'Payment', 'PayLink', 'WithdrawLink', 'Card', 'Charge', 'SubmarineSwap', 'WalletAccount', 'NostrProduct', 'NostrOrder', 'NostrRelay', 'NostrClient', 'NostrNip5', 'SatsdiceLink', 'SatsDiceBet', 'CoinflipSettings', 'Coinflip', 'NumbersGame', 'NumbersBet', 'EightballGame', 'EightballResponse', 'Event', 'EventTicket', 'Invoice', 'InvoicePayment', 'Paywall', 'PaywallAccess', 'BitcoinSwitch', 'SwitchAction', 'LNURLDevice', 'TipJar', 'Tip', 'StreamAlert', 'CopilotAlert'],
                'Payment': ['Wallet'],
                'AccessControlList': ['UserAcls'],
                'UserAcls': ['AccessControlList'],
                'TinyURL': ['Wallet'],
                'WebPushSubscription': ['Account'],
                'PayLink': ['Wallet'],
                'WithdrawLink': ['Wallet'],
                'Card': ['Wallet'],
                'Hit': ['Card'],
                'Refund': ['Hit'],
                'Charge': ['Account'],
                'SatsPayPayment': ['Charge'],
                'SubmarineSwap': ['Wallet'],
                'WalletAccount': ['Account'],
                'NostrProduct': ['Wallet'],
                'NostrOrder': ['NostrProduct'],
                'NostrRelay': ['Wallet'],
                'NostrClient': ['Wallet'],
                'NostrNip5': ['Wallet'],
                'SatsdiceLink': ['Wallet'],
                'SatsDiceBet': ['SatsdiceLink'],
                'CoinflipSettings': ['Wallet'],
                'Coinflip': ['CoinflipSettings'],
                'NumbersGame': ['Wallet'],
                'NumbersBet': ['NumbersGame'],
                'EightballGame': ['Wallet'],
                'EightballResponse': ['EightballGame'],
                'Event': ['Wallet'],
                'EventTicket': ['Event'],
                'Invoice': ['Wallet'],
                'InvoicePayment': ['Invoice'],
                'Paywall': ['Wallet'],
                'PaywallAccess': ['Paywall'],
                'BitcoinSwitch': ['Wallet'],
                'SwitchAction': ['BitcoinSwitch'],
                'LNURLDevice': ['Wallet'],
                'TipJar': ['Wallet'],
                'Tip': ['TipJar'],
                'StreamAlert': ['Wallet'],
                'CopilotAlert': ['Wallet'],
                // Extension-to-Extension relationships
                'SatsPayPayment': ['Charge', 'BtcAddress'], // SatsPay can use onchain addresses
                'BtcAddress': ['SatsPayPayment'], // Onchain addresses used by SatsPay
                'NostrProduct': ['NostrOrder', 'BtcAddress'], // Nostr products can have onchain addresses
                'NostrOrder': ['NostrProduct', 'BtcAddress'], // Nostr orders can use onchain addresses
                'BtcAddress': ['NostrProduct', 'NostrOrder'], // Onchain addresses used by Nostr
                'Event': ['EventTicket', 'PayLink'], // Events can use PayLinks
                'EventTicket': ['Event', 'PayLink'], // Event tickets can use PayLinks
                'PayLink': ['Event', 'EventTicket'], // PayLinks can be used by Events
                'Invoice': ['InvoicePayment', 'PayLink'], // Invoices can use PayLinks
                'InvoicePayment': ['Invoice', 'PayLink'], // Invoice payments can use PayLinks
                'PayLink': ['Invoice', 'InvoicePayment'], // PayLinks can be used by Invoices
                'Paywall': ['PaywallAccess', 'PayLink'], // Paywalls can use PayLinks
                'PaywallAccess': ['Paywall', 'PayLink'], // Paywall access can use PayLinks
                'PayLink': ['Paywall', 'PaywallAccess'], // PayLinks can be used by Paywalls
                'TipJar': ['Tip', 'PayLink'], // TipJars can use PayLinks
                'Tip': ['TipJar', 'PayLink'], // Tips can use PayLinks
                'PayLink': ['TipJar', 'Tip'], // PayLinks can be used by TipJar
                'StreamAlert': ['PayLink'], // StreamAlerts can use PayLinks
                'PayLink': ['StreamAlert'], // PayLinks can be used by StreamAlerts
                'CopilotAlert': ['PayLink'], // CopilotAlerts can use PayLinks
                'PayLink': ['CopilotAlert'], // PayLinks can be used by CopilotAlerts
                'BitcoinSwitch': ['SwitchAction', 'BtcAddress'], // BitcoinSwitch can use onchain addresses
                'SwitchAction': ['BitcoinSwitch', 'BtcAddress'], // SwitchActions can use onchain addresses
                'BtcAddress': ['BitcoinSwitch', 'SwitchAction'], // Onchain addresses used by BitcoinSwitch
                'LNURLDevice': ['BtcAddress'], // LNURL devices can have onchain addresses
                'BtcAddress': ['LNURLDevice'], // Onchain addresses used by LNURL devices
                'WatchOnlyWallet': ['BtcAddress'], // Watch-only wallets monitor onchain addresses
                'BtcAddress': ['WatchOnlyWallet'], // Onchain addresses monitored by watch-only wallets
                'SubmarineSwap': ['BtcAddress'], // Submarine swaps can use onchain addresses
                'BtcAddress': ['SubmarineSwap'], // Onchain addresses used by submarine swaps
                'BoltzSwap': ['BtcAddress'], // Boltz swaps can use onchain addresses
                'BtcAddress': ['BoltzSwap'] // Onchain addresses used by Boltz swaps
            };
            
            // Find dependencies
            if (relationships[tableName]) {
                dependsOn.push(...relationships[tableName]);
            }
            
            // Find what depends on this table
            Object.entries(relationships).forEach(([table, deps]) => {
                if (deps.includes(tableName)) {
                    dependedBy.push(table);
                }
            });
            
            return { dependsOn, dependedBy };
        }
        
        function hideDependencyInfo() {
            const modal = document.getElementById('dependencyInfoModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Export functionality
        function exportCurrentView() {
            console.log('exportCurrentView called');
            
            if (!svg || !g) {
                console.log('SVG or g not found!', {svg: !!svg, g: !!g});
                alert('Schema not loaded yet. Please wait for the page to fully load.');
                return;
            }
            
            try {
                console.log('SVG found, proceeding with export...');
                
                // Get the current SVG element
                const svgElement = document.getElementById('schemaSvg');
                if (!svgElement) {
                    console.log('SVG element not found!');
                    alert('SVG element not found');
                    return;
                }
                
                // Clone the SVG
                const svgClone = svgElement.cloneNode(true);
                
                // Get bounding box with proper padding for headlines
                let bbox;
                try {
                    bbox = g.node().getBBox();
                    console.log('BBox:', bbox);
                    // Add proper padding to include headlines
                    bbox.x -= 20;
                    bbox.y -= 60; // More padding for core headline
                    bbox.width += 40;
                    bbox.height += 120; // More padding for headlines
                } catch (e) {
                    console.log('BBox error:', e);
                    // Fallback to SVG dimensions
                    bbox = {
                        x: -20,
                        y: -60,
                        width: (parseFloat(svgElement.getAttribute('width')) || 1200) + 40,
                        height: (parseFloat(svgElement.getAttribute('height')) || 800) + 120
                    };
                }
                
                // Set proper dimensions
                svgClone.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
                svgClone.setAttribute('width', '1200');
                svgClone.setAttribute('height', '800');
                svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                
                // Convert to data URL
                const svgData = new XMLSerializer().serializeToString(svgClone);
                console.log('SVG data length:', svgData.length);
                
                // Create high-resolution canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                // Ultra high resolution for crisp export
                const dpi = 4; // 4x resolution for ultra crisp text
                canvas.width = 1200 * dpi;
                canvas.height = 800 * dpi;
                
                // Scale context for high DPI
                ctx.scale(dpi, dpi);
                
                // Set background (scaled dimensions)
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, 1200, 800);
                
                img.onload = function() {
                    console.log('Image loaded, drawing to canvas...');
                    ctx.drawImage(img, 0, 0, 1200, 800);
                    
                    // Convert to blob and download
                    canvas.toBlob(function(blob) {
                        if (blob) {
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.download = 'lnbits-schema-export.png';
                            link.href = url;
                            link.click();
                            URL.revokeObjectURL(url);
                            console.log('Export completed successfully');
                        } else {
                            console.log('Blob creation failed');
                            alert('Export failed - could not create image');
                        }
                    }, 'image/png');
                };
                
                img.onerror = function(e) {
                    console.log('Image load error:', e);
                    console.log('Trying fallback SVG download...');
                    
                    // Fallback: Download as SVG file
                    const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                    const svgUrl = URL.createObjectURL(svgBlob);
                    const link = document.createElement('a');
                    link.download = 'lnbits-schema-export.svg';
                    link.href = svgUrl;
                    link.click();
                    URL.revokeObjectURL(svgUrl);
                    console.log('SVG export completed');
                };
                
                // Create data URL
                const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                const svgUrl = URL.createObjectURL(svgBlob);
                img.src = svgUrl;
                
            } catch (error) {
                console.log('Export error:', error);
                alert('Export failed: ' + error.message);
            }
        }
        
        // Print functionality
        function printCurrentView() {
            console.log('printCurrentView called');
            
            // Create a new window for printing
            const printWindow = window.open('', '_blank', 'width=1200,height=800');
            
            if (!printWindow) {
                alert('Please allow popups for printing to work');
                return;
            }
            
            // Get current SVG content
            const svgElement = document.getElementById('schemaSvg');
            if (!svgElement) {
                alert('No schema content found to print');
                return;
            }
            
            // Clone the SVG and modify colors for printing
            const svgClone = svgElement.cloneNode(true);
            
            // Convert all colors for printing - aggressive approach
            try {
                // Force all backgrounds to white and text to dark
                const allElements = svgClone.querySelectorAll('*');
                
                allElements.forEach(el => {
                    const tagName = el.tagName.toLowerCase();
                    
                    // Force white background for all rect elements (table backgrounds)
                    if (tagName === 'rect') {
                        el.setAttribute('fill', 'white');
                        el.setAttribute('stroke', '#333');
                    }
                    
                    // Force dark text for all text elements
                    if (tagName === 'text') {
                        el.setAttribute('fill', '#333');
                    }
                    
                    // Force dark text for all tspan elements
                    if (tagName === 'tspan') {
                        el.setAttribute('fill', '#333');
                    }
                    
                    // Force white background for all circle elements
                    if (tagName === 'circle') {
                        el.setAttribute('fill', 'white');
                        el.setAttribute('stroke', '#333');
                    }
                    
                    // Force white background for all path elements
                    if (tagName === 'path') {
                        el.setAttribute('fill', 'white');
                        el.setAttribute('stroke', '#333');
                    }
                });
                
                // Add a comprehensive style override
                const styleElement = svgClone.querySelector('style');
                if (styleElement) {
                    styleElement.textContent = `
                        * { fill: white !important; color: #333 !important; }
                        rect { fill: white !important; stroke: #333 !important; }
                        text, tspan { fill: #333 !important; }
                        .table-group rect, .extension-table-group rect { fill: white !important; stroke: #333 !important; }
                        .table-header rect { fill: #f0f0f0 !important; stroke: #333 !important; }
                        .table-header text, .field-text { fill: #333 !important; }
                        .fk-link { fill: #0066cc !important; }
                        circle, path { fill: white !important; stroke: #333 !important; }
                    `;
                } else {
                    // Create a new style element if none exists
                    const newStyle = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                    newStyle.textContent = `
                        * { fill: white !important; color: #333 !important; }
                        rect { fill: white !important; stroke: #333 !important; }
                        text, tspan { fill: #333 !important; }
                        .table-group rect, .extension-table-group rect { fill: white !important; stroke: #333 !important; }
                        .table-header rect { fill: #f0f0f0 !important; stroke: #333 !important; }
                        .table-header text, .field-text { fill: #333 !important; }
                        .fk-link { fill: #0066cc !important; }
                        circle, path { fill: white !important; stroke: #333 !important; }
                    `;
                    svgClone.insertBefore(newStyle, svgClone.firstChild);
                }
                
            } catch (error) {
                console.log('Color conversion error:', error);
                // Continue without color modification
            }
            
            const bbox = g.node().getBBox();
            
            // Calculate page dimensions and scale to fit everything
            const pageWidth = 8.5; // inches
            const pageHeight = 11; // inches
            const margin = 0.2; // inches
            const footerHeight = 0.2; // inches for footer
            
            const availableWidth = (pageWidth - 2 * margin) * 96; // Convert to pixels
            const availableHeight = (pageHeight - 2 * margin - footerHeight) * 96; // Convert to pixels
            
            // Add padding for headlines - increased for Core LNbits visibility
            const topPadding = 80; // Space for Core LNbits headline
            const bottomPadding = 20; // Space for footer
            const sidePadding = 20; // Side margins
            
            const paddedBbox = {
                x: bbox.x - sidePadding,
                y: bbox.y - topPadding,
                width: bbox.width + (sidePadding * 2),
                height: bbox.height + topPadding + bottomPadding
            };
            
            // Calculate scale to fit everything on one page
            const scaleX = availableWidth / paddedBbox.width;
            const scaleY = availableHeight / paddedBbox.height;
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up
            
            // Set scaled dimensions
            svgClone.setAttribute('viewBox', `${paddedBbox.x} ${paddedBbox.y} ${paddedBbox.width} ${paddedBbox.height}`);
            svgClone.setAttribute('width', `${paddedBbox.width * scale}px`);
            svgClone.setAttribute('height', `${paddedBbox.height * scale}px`);
            svgClone.style.backgroundColor = 'white'; // White background for printing
            
            // Write the print document - minimal single page
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>LNbits Schema</title>
                    <style>
                        * { margin: 0; padding: 0; box-sizing: border-box; }
                        body { 
                            background: white; 
                            font-family: Arial, sans-serif;
                            padding: 0.2in;
                            width: 8.5in;
                            height: 11in;
                            overflow: hidden;
                        }
                        .print-content {
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                            justify-content: space-between;
                        }
                        #print-content {
                            flex: 1;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            overflow: hidden;
                        }
                        .print-footer { 
                            text-align: center; 
                            font-size: 8px; 
                            color: #666;
                            height: 20px;
                            line-height: 20px;
                            flex-shrink: 0;
                        }
                        @media print { 
                            body { margin: 0; padding: 0.2in; }
                            @page {
                                margin: 0;
                                size: 8.5in 11in;
                            }
                        }
                    </style>
                </head>
                <body>
                    <div class="print-content">
                        <div id="print-content">
                            <!-- SVG will be inserted here -->
                        </div>
                        <div class="print-footer">
                            LNbits Table Town - https://arbadacarbayk.github.io/LNbits_TableTown/
                        </div>
                    </div>
                </body>
                </html>
            `);
            
            // Insert the SVG
            const printContent = printWindow.document.getElementById('print-content');
            if (printContent) {
                printContent.appendChild(svgClone);
            }
            
            printWindow.document.close();
            
            // Wait for content to load, then print
            setTimeout(() => {
                printWindow.focus();
                printWindow.print();
                // Don't close immediately, let user see the result
            }, 1000);
        }

        // Add global click handler to clear FK lines when clicking anywhere
        function setupGlobalClickHandler() {
            document.addEventListener('click', function(event) {
                // Check if click is not on an interactive element
                const isInteractiveElement = event.target.closest('.table-group, .extension-group, .legend-toggle, .legend-explanations, button, input, text, svg, .zoom-btn, .tooltip, .modal-overlay, .fk-line');
                
                if (!isInteractiveElement) {
                    clearFkLines();
                    resetHighlights();
                }
            });
        }

        // Tabs: DB Scheme / API Diff
        (function setupTabs() {
            const buttons = document.querySelectorAll('.tab-btn');
            const schemaContainer = document.getElementById('schemaContainer');
            const apiDiffTab = document.getElementById('apiDiffTab');
            buttons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const tab = btn.getAttribute('data-tab');
                    const pageTitle = document.getElementById('pageTitle');
                    const pageSubtitle = document.getElementById('pageSubtitle');
                    
                    if (tab === 'schemaTab') {
                        schemaContainer.style.display = 'block';
                        apiDiffTab.style.display = 'none';
                        if (pageTitle) pageTitle.textContent = 'LNbits Table Town';
                        if (pageSubtitle) pageSubtitle.style.display = 'none';
                        
                        // Show controls for DB Scheme tab
                        const dbControls = document.getElementById('dbControls');
                        if (dbControls) {
                            dbControls.style.display = 'flex';
                        }
                        
                        // Reset schema container to natural height
                        schemaContainer.style.height = 'auto';
                        schemaContainer.style.minHeight = 'auto';
                        schemaContainer.style.maxHeight = 'none';
                        
                        // Hide API Diff results when switching to DB Scheme
                        const apiDiffResults = document.getElementById('apiDiffResults');
                        if (apiDiffResults) {
                            apiDiffResults.style.display = 'none';
                            // Don't clear content - just hide it
                        }
                        
                        // Only render schema if SVG doesn't exist yet
                        setTimeout(() => {
                            const existingSvg = document.getElementById('schemaSvg');
                            if (!existingSvg && typeof buildSvgAndRender === 'function') {
                                console.log('Initial schema render...');
                                buildSvgAndRender();
                            }
                        }, 100);
                    } else {
                        schemaContainer.style.display = 'none';
                        apiDiffTab.style.display = 'block';
                        if (pageTitle) pageTitle.textContent = 'LNbits API Town';
                        if (pageSubtitle) pageSubtitle.style.display = 'block';
                        
                        // Hide controls for API Diff tab
                        const dbControls = document.getElementById('dbControls');
                        if (dbControls) {
                            dbControls.style.display = 'none';
                        }
                        
                        // Reset API diff container to natural height
                        apiDiffTab.style.height = 'auto';
                        apiDiffTab.style.minHeight = 'auto';
                        apiDiffTab.style.maxHeight = 'none';
                        
                        // If API Diff tab is selected and there are results, show them
                        const apiDiffResults = document.getElementById('apiDiffResults');
                        if (apiDiffResults && apiDiffResults.innerHTML.trim()) {
                            apiDiffResults.style.display = 'block';
                        }
                    }
                });
            });
        })();

        // API Diff logic
        function switchToApiDiff() {
            const schemaContainer = document.getElementById('schemaContainer');
            const apiDiffTab = document.getElementById('apiDiffTab');
            const pageTitle = document.getElementById('pageTitle');
            const pageSubtitle = document.getElementById('pageSubtitle');
            const dbControls = document.getElementById('dbControls');
            if (schemaContainer) schemaContainer.style.display = 'none';
            if (apiDiffTab) apiDiffTab.style.display = 'block';
            if (pageTitle) pageTitle.textContent = 'LNbits API Town';
            if (pageSubtitle) pageSubtitle.style.display = 'block';
            if (dbControls) dbControls.style.display = 'none';
            // mark tab buttons if present
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(b=>b.classList.remove('active'));
            const apiBtn = Array.from(buttons).find(b=>b.getAttribute('data-tab')==='apiDiffTab');
            if (apiBtn) apiBtn.classList.add('active');
        }
        const apiState = { left: null, right: null };

        async function fetchJson(url) {
            console.log('Fetching URL:', url);
            try {
                const res = await fetch(url);
                if (!res.ok) {
                    throw new Error(`Failed to fetch ${url}: ${res.status} ${res.statusText}`);
                }
                const data = await res.json();
                console.log('Successfully fetched data from:', url);
                return data;
            } catch (error) {
                console.error('Error fetching URL:', url, error);
                throw error;
            }
        }

        function readFileAsJson(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    try { resolve(JSON.parse(reader.result)); } catch (e) { reject(e); }
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function summarizeSpec(spec) {
            const title = (spec && spec.info && spec.info.title) ? spec.info.title : 'Unknown';
            const version = (spec && spec.info && spec.info.version) ? spec.info.version : 'unspecified';
            const numPaths = spec && spec.paths ? Object.keys(spec.paths).length : 0;
            return `${title} — v${version} · ${numPaths} paths`;
        }

        // Attach an extension->version map onto a spec for later use in headers
        function attachExtensionVersions(spec, extensionSpecsOptional) {
            try {
                const versionMap = {};
                // If we were given discrete extension specs (right side), prefer manifest info, then info.version
                if (extensionSpecsOptional) {
                    Object.entries(extensionSpecsOptional).forEach(([extName, extSpec]) => {
                        let v;
                        // First try manifest info (most reliable)
                        if (extSpec && extSpec._manifestInfo && extSpec._manifestInfo.version) {
                            v = String(extSpec._manifestInfo.version);
                        }
                        // Fallback to info.version
                        else if (extSpec && extSpec.info && extSpec.info.version) {
                            v = String(extSpec.info.version);
                        }
                        if (v) versionMap[extName.toLowerCase()] = v;
                    });
                }
                // Also try to discover versions from tags metadata on the spec (left side or fallback)
                if (spec && Array.isArray(spec.tags)) {
                    spec.tags.forEach(tag => {
                        const name = (tag && tag.name ? String(tag.name).toLowerCase() : '').trim();
                        if (!name) return;
                        const desc = tag && tag.description ? String(tag.description) : '';
                        const m = desc.match(/v?(\d+\.\d+\.\d+(?:[-+][0-9A-Za-z.-]+)?)/);
                        if (m && !versionMap[name]) {
                            versionMap[name] = m[1];
                        }
                        // Support custom field x-extension-version if present
                        if (tag && tag['x-extension-version'] && !versionMap[name]) {
                            versionMap[name] = String(tag['x-extension-version']);
                        }
                    });
                }
                // Stash on the spec for easy lookup later
                Object.defineProperty(spec, '_extVersions', { value: versionMap, enumerable: false, configurable: true });
            } catch (_) {
                // ignore
            }
        }

        async function fetchLatestFromGitHub(leftSpec) {
            try {
                // Extract installed extensions from left spec
                const installedExtensions = new Set();
                if (leftSpec && leftSpec.paths) {
                    for (const path of Object.keys(leftSpec.paths)) {
                        const segments = path.split('/').filter(Boolean);
                        if (segments.length > 0 && segments[0] !== 'api' && segments[0] !== 'public' && segments[0] !== 'users' && segments[0] !== 'admin') {
                            installedExtensions.add(segments[0]);
                        }
                    }
                }
                
                console.log('Found installed extensions:', Array.from(installedExtensions));
                
                // Fetch extensions manifest to get version info
                const manifestResponse = await fetch('https://raw.githubusercontent.com/lnbits/lnbits-extensions/main/extensions.json');
                const manifest = await manifestResponse.json();
                const extensionVersions = {};
                
                // Build version map from manifest
                if (manifest.extensions) {
                    manifest.extensions.forEach(ext => {
                        const key = ext.id.toLowerCase();
                        extensionVersions[key] = {
                            version: ext.version,
                            max_lnbits_version: ext.max_lnbits_version,
                            repo: ext.repo,
                            name: ext.name,
                            short_description: ext.short_description
                        };
                    });
                }
                
                // Fetch complete spec from demo.lnbits.com (has latest core + extension APIs)
                // This gives us the most complete API coverage
                const coreResponse = await fetch('https://demo.lnbits.com/openapi.json');
                const coreSpec = await coreResponse.json();
                
                // Use demo.lnbits.com for complete API spec (core + extensions)
                // This gives us the most complete and reliable API coverage
                const extensionSpecs = {}; // Empty since demo.lnbits.com has everything
                
                console.log('Using demo.lnbits.com for complete API spec');
                
                // Attach discovered versions onto coreSpec as a map for later lookup
                attachExtensionVersions(coreSpec, extensionSpecs);
                
                // Also attach the manifest versions directly to coreSpec for easy access
                coreSpec._manifestVersions = extensionVersions;
                console.log('Attached manifest versions to coreSpec:', Object.keys(extensionVersions));
                
                console.log('Extension specs with manifest info:', Object.keys(extensionSpecs).map(k => ({
                    name: k, 
                    version: extensionSpecs[k]._manifestInfo?.version || 'no manifest',
                    hasManifest: !!extensionSpecs[k]._manifestInfo
                })));
                
                return {
                    core: coreSpec,
                    extensions: extensionSpecs,
                    manifest: extensionVersions
                };
            } catch (error) {
                console.error('Failed to fetch from GitHub:', error);
                return null;
            }
        }

        function buildOpIndex(spec) {
            const index = new Map();
            if (!spec || !spec.paths) return index;
            for (const [path, pathItem] of Object.entries(spec.paths)) {
                for (const method of ['get','post','put','patch','delete','options','head']) {
                    const op = pathItem[method];
                    if (op) {
                        index.set(`${method.toUpperCase()} ${path}`, op);
                    }
                }
            }
            return index;
        }

        function compareOperations(opA, opB) {
            const diffs = [];
            if (!opA || !opB) return diffs;
            
            // Basic operation changes
            if ((opA.summary||'') !== (opB.summary||'')) diffs.push('summary');
            if ((opA.operationId||'') !== (opB.operationId||'')) diffs.push('operationId');
            if (!!opA.deprecated !== !!opB.deprecated) diffs.push('deprecated flag');
            
            // Detailed parameter comparison
            const compareParams = (paramsA, paramsB) => {
                if (!paramsA && !paramsB) return true;
                if (!paramsA || !paramsB) return false;
                if (paramsA.length !== paramsB.length) return false;
                
                const normalizeParam = (p) => `${p.in}:${p.name}:${p.type||p.schema?.type||'unknown'}:${!!p.required}`;
                const sortedA = paramsA.map(normalizeParam).sort();
                const sortedB = paramsB.map(normalizeParam).sort();
                return JSON.stringify(sortedA) === JSON.stringify(sortedB);
            };
            
            if (!compareParams(opA.parameters, opB.parameters)) {
                diffs.push('parameters (names, types, or required status)');
            }
            
            // Request body comparison
            const compareRequestBody = (rbA, rbB) => {
                if (!rbA && !rbB) return true;
                if (!rbA || !rbB) return false;
                const ctA = rbA.content ? Object.keys(rbA.content).sort().join(',') : '';
                const ctB = rbB.content ? Object.keys(rbB.content).sort().join(',') : '';
                return ctA === ctB;
            };
            
            if (!compareRequestBody(opA.requestBody, opB.requestBody)) {
                diffs.push('requestBody content types');
            }
            
            // Response comparison
            const compareResponses = (respA, respB) => {
                if (!respA && !respB) return true;
                if (!respA || !respB) return false;
                const keysA = Object.keys(respA).sort();
                const keysB = Object.keys(respB).sort();
                return JSON.stringify(keysA) === JSON.stringify(keysB);
            };
            
            if (!compareResponses(opA.responses, opB.responses)) {
                diffs.push('response status codes');
            }
            
            // Security requirements
            const secA = opA.security || [];
            const secB = opB.security || [];
            if (JSON.stringify(secA) !== JSON.stringify(secB)) {
                diffs.push('security requirements');
            }
            
            return diffs;
        }

        function computeDiff(leftSpec, rightSpec) {
            const leftIdx = buildOpIndex(leftSpec);
            const rightIdx = buildOpIndex(rightSpec);
            const leftKeys = new Set(leftIdx.keys());
            const rightKeys = new Set(rightIdx.keys());

            let added = [];
            let removed = [];
            const changed = [];
            const deprecated = [];

            for (const key of rightKeys) if (!leftKeys.has(key)) added.push(key);
            for (const key of leftKeys) if (!rightKeys.has(key)) removed.push(key);
            for (const key of rightKeys) {
                if (leftKeys.has(key)) {
                    const diffs = compareOperations(leftIdx.get(key), rightIdx.get(key));
                    if (diffs.length) changed.push(`${key} — ${diffs.join(', ')}`);
                    // Only mark as deprecated if the endpoint is actually deprecated in the current version (right side)
                    const rightOp = rightIdx.get(key);
                    if (rightOp?.deprecated) {
                        deprecated.push(`${key}`);
                    }
                }
            }
            
            // Also check left-only endpoints for deprecation
            for (const key of leftKeys) {
                if (!rightKeys.has(key)) {
                    const leftOp = leftIdx.get(key);
                    if (leftOp?.deprecated) {
                        deprecated.push(`${key} (removed but was deprecated)`);
                    }
                }
            }

            // Pair similar endpoints (same method + normalized path template) as modifications
            const parseKey = (k)=>{ const sp=k.indexOf(' '); return {method:k.slice(0,sp), path:k.slice(sp+1), raw:k}; };
            const normPath = (p)=> p.replace(/\{[^}]+\}/g,'{}');
            const leftParsed = removed.map(parseKey);
            const rightParsed = added.map(parseKey);
            const rightBySig = new Map();
            rightParsed.forEach(r=>{ const sig = r.method+" "+normPath(r.path); if (!rightBySig.has(sig)) rightBySig.set(sig, []); rightBySig.get(sig).push(r); });
            const changedPairs = [];
            const consumedAdded = new Set();
            const consumedRemoved = new Set();
            leftParsed.forEach(lp=>{
                const sig = lp.method+" "+normPath(lp.path);
                const candidates = rightBySig.get(sig) || [];
                if (candidates.length) {
                    const rp = candidates.shift();
                    consumedRemoved.add(lp.raw);
                    consumedAdded.add(rp.raw);
                    // Diff details
                    const details = [];
                    if (lp.path !== rp.path) {
                        const leftVars = Array.from(lp.path.matchAll(/\{([^}]+)\}/g)).map(m=>m[1]);
                        const rightVars = Array.from(rp.path.matchAll(/\{([^}]+)\}/g)).map(m=>m[1]);
                        if (leftVars.join(',') !== rightVars.join(',')) {
                            details.push(`path params: ${leftVars.join(',')||'none'} → ${rightVars.join(',')||'none'}`);
                        } else {
                            details.push('path template changed');
                        }
                    }
                    const opDiffs = compareOperations(leftIdx.get(lp.raw), rightIdx.get(rp.raw));
                    if (opDiffs.length) details.push(opDiffs.join(', '));
                    changedPairs.push({ left: lp.raw, right: rp.raw, details });
                }
            });
            // Filter out consumed from added/removed
            added = added.filter(a=> !consumedAdded.has(a));
            removed = removed.filter(r=> !consumedRemoved.has(r));

            // naive replacement suggestions among remaining added/removed
            const replacements = [];
            const addedParsed2 = added.map(parseKey);
            const removedParsed2 = removed.map(parseKey);
            removedParsed2.forEach(rm=>{
                const tail = rm.path.split('/').slice(-2).join('/');
                const cand = addedParsed2.find(ad=> ad.method===rm.method && (ad.path.endsWith(tail) || ad.path.replace(/\{.*?\}/g,'{}')===rm.path.replace(/\{.*?\}/g,'{}')));
                if (cand) replacements.push(`${rm.method} ${rm.path} → ${cand.method} ${cand.path}`);
            });

            return { added, removed, changed, deprecated, replacements, changedPairs };
        }

        function renderDiff(leftSpec, rightSpec) {
            // Only render if API Diff tab is visible
            const apiDiffTab = document.getElementById('apiDiffTab');
            if (!apiDiffTab || apiDiffTab.style.display === 'none') {
                console.log('API Diff tab is not visible, skipping renderDiff');
                return;
            }
            
            const container = document.getElementById('apiDiffResults');
            if (!container) {
                console.error('apiDiffResults container not found!');
                return;
            }
            console.log('Found apiDiffResults container:', container);
            console.log('Container parent:', container.parentElement);
            console.log('Container is in API Diff tab:', container.closest('#apiDiffTab') !== null);
            container.style.display = 'block';
            
            // Create summary and result elements if they don't exist
            let summary = document.getElementById('apiDiffSummary');
            if (!summary) {
                summary = document.createElement('div');
                summary.id = 'apiDiffSummary';
                container.appendChild(summary);
            }
            
            let ulAdded = document.getElementById('diffAdded');
            if (!ulAdded) {
                ulAdded = document.createElement('ul');
                ulAdded.id = 'diffAdded';
                container.appendChild(ulAdded);
            }
            
            let ulRemoved = document.getElementById('diffRemoved');
            if (!ulRemoved) {
                ulRemoved = document.createElement('ul');
                ulRemoved.id = 'diffRemoved';
                container.appendChild(ulRemoved);
            }
            
            let ulChanged = document.getElementById('diffChanged');
            if (!ulChanged) {
                ulChanged = document.createElement('ul');
                ulChanged.id = 'diffChanged';
                container.appendChild(ulChanged);
            }
            
            let ulDeprecated = document.getElementById('diffDeprecated');
            if (!ulDeprecated) {
                ulDeprecated = document.createElement('ul');
                ulDeprecated.id = 'diffDeprecated';
                container.appendChild(ulDeprecated);
            }
            try {
                console.log('Computing diff...');
                const startTime = Date.now();
                const { added, removed, changed, deprecated, replacements, changedPairs } = computeDiff(leftSpec, rightSpec);
                const diffTime = Date.now() - startTime;
                console.log(`Diff computation took ${diffTime}ms`);
                
                const leftTitle = summarizeSpec(leftSpec);
                const rightTitle = summarizeSpec(rightSpec);
                
                console.log('Diff results:', { added: added.length, removed: removed.length, changed: changed.length, deprecated: deprecated.length });
                console.log('Added endpoints:', added.slice(0, 5)); // Show first 5 added
                console.log('Removed endpoints:', removed.slice(0, 5)); // Show first 5 removed
                console.log('Changed endpoints:', changed.slice(0, 5)); // Show first 5 changed
                
                // Create summary HTML
                const summaryHtml = `
                    <div style="background: #2a2a2a; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                        <h4 style="color: #4CAF50; margin-bottom: 0.5rem;">Comparison Summary</h4>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
                            <div style="text-align: center;">
                                <div style="color: #4CAF50; font-size: 1.5rem; font-weight: bold;">${added.length}</div>
                                <div style="color: #ccc; font-size: 0.9rem;">Added</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #f44336; font-size: 1.5rem; font-weight: bold;">${removed.length}</div>
                                <div style="color: #ccc; font-size: 0.9rem;">Removed</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #ff9800; font-size: 1.5rem; font-weight: bold;">${changed.length}</div>
                                <div style="color: #ccc; font-size: 0.9rem;">Changed</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #9c27b0; font-size: 1.5rem; font-weight: bold;">${deprecated.length}</div>
                                <div style="color: #ccc; font-size: 0.9rem;">Deprecated</div>
                            </div>
                        </div>
                    </div>
                `;
                
                summary.innerHTML = summaryHtml;
                
                // Force the container to be visible
                container.style.display = 'block';
                container.style.visibility = 'visible';
                console.log('Container should now be visible with summary');
                
                // Create split columns if they don't exist
                let leftCol = document.getElementById('leftChanges');
                let rightCol = document.getElementById('rightChanges');
                if (!leftCol || !rightCol) {
                    const splitCols = document.createElement('div');
                    splitCols.id = 'splitColumns';
                    splitCols.style.cssText = 'display:flex;gap:12px;align-items:flex-start;margin-top:8px;';
                    
                    leftCol = document.createElement('div');
                    leftCol.id = 'leftChanges';
                    leftCol.style.cssText = 'flex:1 1 0;min-width:0;';
                    leftCol.innerHTML = '<h4 style="color:#ccc">Left (baseline)</h4>';
                    
                    rightCol = document.createElement('div');
                    rightCol.id = 'rightChanges';
                    rightCol.style.cssText = 'flex:1 1 0;min-width:0;';
                    rightCol.innerHTML = '<h4 style="color:#ccc">Right (comparison)</h4>';
                    
                    splitCols.appendChild(leftCol);
                    splitCols.appendChild(rightCol);
                    container.appendChild(splitCols);
                }

                const ownerOf = (entry)=>{
                    if (typeof entry !== 'string') return 'unknown';
                    const m = entry.match(/^([A-Z]+)\s+([^<]+)/);
                    const path = m ? m[2] : entry;
                    const segs = path.split('/').filter(Boolean);
                    if (!segs.length) return 'unknown';
                    if (segs[0]==='api' || segs[0]==='public' || segs[0]==='users') return 'core';
                    return segs[0];
                };
                const renderGroupedList = (items)=>{
                    const groups = {};
                    (items||[]).forEach(i=>{ const key=ownerOf(i); (groups[key]=groups[key]||[]).push(i); });
                    const order = Object.keys(groups).sort((a,b)=> a==='core'? -1 : (b==='core'?1 : a.localeCompare(b)));
                    return order.map(k=>{
                        const title = k==='core' ? 'Core' : `Extension: ${k}`;
                        const lis = groups[k].map(i=>`<li>${i}</li>`).join('');
                        return `<li style=\"list-style:none;margin:6px 0;\"><div style=\"color:#ccc;font-weight:bold;\">${title} (${groups[k].length})</div><ul>${lis}</ul></li>`;
                    }).join('');
                };

                // Build per-side datasets - show only what exists on each side
                const leftOnly = removed.slice(); // items only on left
                const rightOnly = added.slice(); // items only on right
                const leftChanged = changedPairs.map(p=>`${p.left}<br/><span class=\"diff-changed\">${(p.details||[]).join('; ')||'modified'}</span>`);
                const rightChanged = changedPairs.map(p=>`${p.right}<br/><span class=\"diff-changed\">${(p.details||[]).join('; ')||'modified'}</span>`);

                const leftOnlyHtml = leftOnly.length > 0 ? renderGroupedList(leftOnly) : '<li>None</li>';
                const rightOnlyHtml = rightOnly.length > 0 ? renderGroupedList(rightOnly) : '<li>None</li>';
                const leftChangedHtml = leftChanged.length > 0 ? renderGroupedList(leftChanged) : '<li>None</li>';
                const rightChangedHtml = rightChanged.length > 0 ? renderGroupedList(rightChanged) : '<li>None</li>';

                // Render paired comparison table and focus it
                let paired = document.getElementById('pairedCompare');
                if (!paired) {
                    paired = document.createElement('div');
                    paired.id = 'pairedCompare';
                    container.appendChild(paired);
                }
                if (paired) {
                    paired.innerHTML = `<h4 style=\"color:#ccc;margin-top:12px;\">Paired Comparison (row-by-row)</h4>`;
                    try {
                        paired.innerHTML += buildPairedRows(leftOnly, rightOnly, changedPairs, leftSpec, rightSpec, deprecated);
                    } catch (e) {
                        console.error('buildPairedRows error:', e);
                        console.log('leftOnly:', leftOnly.length, 'rightOnly:', rightOnly.length, 'changedPairs:', changedPairs.length);
                        paired.innerHTML += '<p>Error building comparison table</p>';
                    }
                    const splitCols = document.getElementById('splitColumns');
                    if (splitCols) splitCols.style.display = 'none';
                    paired.scrollIntoView({ behavior: 'auto', block: 'start' });
                    
                    // Add click handlers for collapsible groups
                    paired.querySelectorAll('.paired-group').forEach(group => {
                        group.addEventListener('click', () => {
                            group.classList.toggle('collapsed');
                        });
                    });
                }

                if (leftCol) {
                    leftCol.innerHTML = `<h4 style=\"color:#ccc\">Left (baseline) — ${leftTitle}</h4>
                        <div style=\"color:#888;margin:4px 0;\">Only on Left: ${leftOnly.length} · Changed: ${leftChanged.length}</div>
                        <div style=\"color:#ccc\"><strong>Only on Left</strong></div>
                        <ul class=\"diff-list\">${leftOnlyHtml||'<li>None</li>'}</ul>
                        <div style=\"margin-top:8px; color:#ccc;\"><strong>Changed (this side)</strong></div>
                        <ul class=\"diff-list\">${leftChangedHtml||'<li>None</li>'}</ul>`;
                }
                if (rightCol) {
                    rightCol.innerHTML = `<h4 style=\"color:#ccc\">Right (comparison) — ${rightTitle}</h4>
                        <div style=\"color:#888;margin:4px 0;\">Only on Right: ${rightOnly.length} · Changed: ${rightChanged.length} · Deprecated: ${deprecated.length}</div>
                        <div class=\"diff-added\"><strong>Only on Right</strong></div>
                        <ul class=\"diff-list\">${rightOnlyHtml||'<li>None</li>'}</ul>
                        <div style=\"margin-top:8px; color:#ccc;\"><strong>Changed (this side)</strong></div>
                        <ul class=\"diff-list\">${rightChangedHtml||'<li>None</li>'}</ul>`;
                }

                // Paired comparison table is now the main view
                container.style.display = 'block';
                const compat = document.getElementById('compatImpactPanel');
                if (compat) compat.style.display = 'block';
                
                // Scroll the results container to top to show the summary counts
                container.scrollTop = 0;
            } catch (e) {
                console.error('renderDiff error', e);
                if (ulAdded && ulRemoved && ulChanged && ulDeprecated) {
                    const d = computeDiff(leftSpec,rightSpec);
                    ulAdded.innerHTML = (d.added||[]).map(i=>`<li>${i}</li>`).join('');
                    ulRemoved.innerHTML = (d.removed||[]).map(i=>`<li>${i}</li>`).join('');
                    ulChanged.innerHTML = (d.changed||[]).map(i=>`<li>${i}</li>`).join('');
                    ulDeprecated.innerHTML = (d.deprecated||[]).map(i=>`<li>${i}</li>`).join('');
                    container.style.display = 'block';
                    
                    // Scroll the results container to top to show the summary counts
                    container.scrollTop = 0;
                }
            }
        }

        function updateMeta(side, spec) {
            const el = document.getElementById(side === 'left' ? 'leftMeta' : 'rightMeta');
            el.textContent = spec ? summarizeSpec(spec) : 'No spec loaded.';
        }

        function normalizeUrl(u){
            if (!u) return u;
            if (/^https?:\/\//i.test(u)) {
                // URL already has protocol, check if it needs /openapi.json
                if (!u.endsWith('/openapi.json')) {
                    return u.endsWith('/') ? u + 'openapi.json' : u + '/openapi.json';
                }
                return u;
            }
            // Remove leading slashes and add https://
            const cleanUrl = u.replace(/^\/*/, '');
            const baseUrl = 'https://' + cleanUrl;
            // Append /openapi.json if not already present
            return baseUrl.endsWith('/openapi.json') ? baseUrl : 
                   baseUrl.endsWith('/') ? baseUrl + 'openapi.json' : 
                   baseUrl + '/openapi.json';
        }

        async function handleLoadUrl(side) {
            const input = document.getElementById(side === 'left' ? 'leftUrl' : 'rightUrl');
            if (side === 'right' && !input.value) return; // Only require URL for manual right side loading
            
            try {
                if (side === 'left') {
                    // Load live installation
                    const spec = await fetchJson(normalizeUrl(input.value));
                    // Attach any extension versions we can infer from tags
                    attachExtensionVersions(spec);
                    
                    // Also fetch manifest data for extension versions
                    try {
                        const manifestResponse = await fetch('https://raw.githubusercontent.com/lnbits/lnbits-extensions/main/extensions.json');
                        const manifestData = await manifestResponse.json();
                        const extensionVersions = {};
                        manifestData.extensions.forEach(ext => {
                            const key = ext.id.toLowerCase();
                            extensionVersions[key] = {
                                version: ext.version,
                                name: ext.name,
                                short_description: ext.short_description
                            };
                        });
                        spec._manifestVersions = extensionVersions;
                        console.log('Left side manifest versions:', extensionVersions);
                    } catch (e) {
                        console.log('Could not load manifest for left side:', e);
                    }
                    
                    apiState[side] = spec;
                    updateMeta(side, spec);
                    switchToApiDiff();
                    
                    // Auto-load latest GitHub releases for comparison
                    if (spec) {
                        const rightInput = document.getElementById('rightUrl');
                        rightInput.value = 'Loading latest from GitHub...';
                        rightInput.disabled = true;
                        
                        const githubData = await fetchLatestFromGitHub(spec);
                        if (githubData) {
                            // Combine core and extension specs for comparison
                            const combinedSpec = {
                                ...githubData.core,
                                paths: { ...githubData.core.paths }
                            };
                            
                            // Add extension paths to the combined spec
                            Object.keys(githubData.extensions).forEach(extName => {
                                const extSpec = githubData.extensions[extName];
                                if (extSpec && extSpec.paths) {
                                    Object.keys(extSpec.paths).forEach(path => {
                                        combinedSpec.paths[path] = extSpec.paths[path];
                                    });
                                }
                            });
                            
                            // Carry over the extension version map and manifest data
                            attachExtensionVersions(combinedSpec, githubData.extensions);
                            combinedSpec._manifestVersions = githubData.manifest;
                            
                            console.log('Right side manifest versions:', githubData.manifest);
                            console.log('Extension specs found:', Object.keys(githubData.extensions));
                            
                            apiState.right = combinedSpec;
                            updateMeta('right', combinedSpec);
                            rightInput.value = `Latest GitHub Release (${Object.keys(githubData.extensions).length} extensions)`;
                            rightInput.disabled = false;
                            renderDiff(apiState.left, apiState.right);
                        } else {
                            rightInput.value = 'Failed to load GitHub data';
                            rightInput.disabled = false;
                        }
                    }
                } else {
                    // Manual right side loading
                    const spec = await fetchJson(normalizeUrl(input.value));
                    attachExtensionVersions(spec);
                    apiState[side] = spec;
                    updateMeta(side, spec);
                    switchToApiDiff();
                    if (apiState.left && apiState.right) renderDiff(apiState.left, apiState.right);
                }
            } catch (e) {
                updateMeta(side, null);
                alert(`Failed to load ${side} spec: ${e.message}`);
            }
        }

        async function handleLoadFile(side) {
            const input = document.getElementById(side === 'left' ? 'leftFile' : 'rightFile');
            if (!input.files || !input.files[0]) return;
            try {
                const spec = await readFileAsJson(input.files[0]);
                apiState[side] = spec;
                updateMeta(side, spec);
                switchToApiDiff();
                if (apiState.left && apiState.right) renderDiff(apiState.left, apiState.right);
            } catch (e) {
                updateMeta(side, null);
                alert(`Failed to parse ${side} file: ${e.message}`);
            } finally {
                input.value = '';
            }
        }

        // New workflow handlers
        async function handleCompareToDemo() {
            const originInput = document.getElementById('originUrl');
            if (!originInput.value.trim()) {
                alert('Please enter your LNbits instance URL');
                return;
            }
            
            // Show loading state
            const button = document.getElementById('compareToDemo');
            const originalText = button.textContent;
            button.textContent = 'Loading...';
            button.disabled = true;
            
            try {
                console.log('Starting comparison to demo...');
                
                // Add timeout to prevent hanging
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000)
                );
                
                const fetchPromise = (async () => {
                    // Load origin spec
                    console.log('Fetching origin spec...');
                    const originSpec = await fetchJson(normalizeUrl(originInput.value));
                    attachExtensionVersions(originSpec);
                    
                    // Load manifest data for extension versions
                    try {
                        console.log('Loading manifest...');
                        const manifestResponse = await fetch('https://raw.githubusercontent.com/lnbits/lnbits-extensions/main/extensions.json');
                        const manifestData = await manifestResponse.json();
                        const extensionVersions = {};
                        manifestData.extensions.forEach(ext => {
                            const key = ext.id.toLowerCase();
                            extensionVersions[key] = {
                                version: ext.version,
                                name: ext.name,
                                short_description: ext.short_description
                            };
                        });
                        originSpec._manifestVersions = extensionVersions;
                    } catch (e) {
                        console.log('Could not load manifest for origin:', e);
                    }
                    
                    // Load demo spec
                    console.log('Fetching demo spec...');
                    const demoSpec = await fetchJson('https://demo.lnbits.com/openapi.json');
                    attachExtensionVersions(demoSpec);
                    demoSpec._manifestVersions = originSpec._manifestVersions; // Use same manifest
                    
                    // Store specs
                    apiState.left = originSpec;
                    apiState.right = demoSpec;
                    
                    console.log('Rendering comparison...');
                    // Update UI
                    updateComparisonUI('Your Installation', 'demo.lnbits.com', originSpec, demoSpec);
                    renderDiff(originSpec, demoSpec);
                    
                    console.log('Demo comparison completed successfully');
                })();
                
                await Promise.race([fetchPromise, timeoutPromise]);
                
            } catch (error) {
                console.error('Failed to compare to demo:', error);
                if (error.message.includes('timeout')) {
                    alert('Request timed out. The servers might be slow or unresponsive. Please try again.');
                } else if (error.message.includes('CORS')) {
                    alert('CORS error: Cannot access your LNbits instance from this browser. Make sure your instance allows CORS requests.');
                } else {
                    alert('Failed to load specs. Please check your URL and try again. Error: ' + error.message);
                }
            } finally {
                // Reset button state
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        async function handleCompareCustom() {
            const leftInput = document.getElementById('leftUrl');
            const rightInput = document.getElementById('rightUrl');
            
            if (!leftInput.value.trim() || !rightInput.value.trim()) {
                alert('Please enter both URLs to compare');
                return;
            }
            
            // Show loading state
            const button = document.getElementById('compareCustom');
            const originalText = button.textContent;
            button.textContent = 'Loading...';
            button.disabled = true;
            
            try {
                console.log('Starting comparison...');
                
                // Add timeout to prevent hanging
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000)
                );
                
                const fetchPromise = (async () => {
                    // Load both specs
                    console.log('Fetching left spec...');
                    const leftSpec = await fetchJson(normalizeUrl(leftInput.value));
                    console.log('Fetching right spec...');
                    const rightSpec = await fetchJson(normalizeUrl(rightInput.value));
                    
                    console.log('Processing specs...');
                    attachExtensionVersions(leftSpec);
                    attachExtensionVersions(rightSpec);
                    
                    // Load manifest data for both
                    try {
                        console.log('Loading manifest...');
                        const manifestResponse = await fetch('https://raw.githubusercontent.com/lnbits/lnbits-extensions/main/extensions.json');
                        const manifestData = await manifestResponse.json();
                        const extensionVersions = {};
                        manifestData.extensions.forEach(ext => {
                            const key = ext.id.toLowerCase();
                            extensionVersions[key] = {
                                version: ext.version,
                                name: ext.name,
                                short_description: ext.short_description
                            };
                        });
                        leftSpec._manifestVersions = extensionVersions;
                        rightSpec._manifestVersions = extensionVersions;
                    } catch (e) {
                        console.log('Could not load manifest:', e);
                    }
                    
                    // Store specs
                    apiState.left = leftSpec;
                    apiState.right = rightSpec;
                    
                    console.log('Rendering comparison...');
                    // Update UI
                    updateComparisonUI('Left Instance', 'Right Instance', leftSpec, rightSpec);
                    renderDiff(leftSpec, rightSpec);
                    
                    console.log('Comparison completed successfully');
                })();
                
                await Promise.race([fetchPromise, timeoutPromise]);
                
            } catch (error) {
                console.error('Failed to compare custom URLs:', error);
                if (error.message.includes('timeout')) {
                    alert('Request timed out. The servers might be slow or unresponsive. Please try again.');
                } else if (error.message.includes('CORS')) {
                    alert('CORS error: Cannot access the specified URLs from this browser. Try using the "Compare to demo" option instead.');
                } else {
                    alert('Failed to load specs. Please check your URLs and try again. Error: ' + error.message);
                }
            } finally {
                // Reset button state
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        function updateComparisonUI(leftTitle, rightTitle, leftSpec, rightSpec) {
            const leftTitleEl = document.getElementById('leftTitle');
            const rightTitleEl = document.getElementById('rightTitle');
            const leftMetaEl = document.getElementById('leftMeta');
            const rightMetaEl = document.getElementById('rightMeta');
            
            if (leftTitleEl) leftTitleEl.textContent = leftTitle;
            if (rightTitleEl) rightTitleEl.textContent = rightTitle;
            if (leftMetaEl) leftMetaEl.textContent = leftSpec ? summarizeSpec(leftSpec) : 'No spec loaded.';
            if (rightMetaEl) rightMetaEl.textContent = rightSpec ? summarizeSpec(rightSpec) : 'No spec loaded.';
            
            // Show the apiDiffResults container (which contains the comparison results)
            const apiDiffResults = document.getElementById('apiDiffResults');
            if (apiDiffResults) {
                apiDiffResults.style.display = 'block';
                console.log('API Diff results div should now be visible');
            } else {
                console.error('apiDiffResults element not found!');
            }
        }

        // New workflow buttons
        document.getElementById('compareToDemo').addEventListener('click', () => handleCompareToDemo());
        document.getElementById('compareCustom').addEventListener('click', () => handleCompareCustom());
        
        // Legacy buttons (for backward compatibility)
        const loadLeftBtn = document.getElementById('loadLeftUrl');
        const loadRightBtn = document.getElementById('loadRightUrl');
        const loadLeftFileBtn = document.getElementById('loadLeftFile');
        const loadRightFileBtn = document.getElementById('loadRightFile');
        
        if (loadLeftBtn) loadLeftBtn.addEventListener('click', () => handleLoadUrl('left'));
        if (loadRightBtn) loadRightBtn.addEventListener('click', () => handleLoadUrl('right'));
        if (loadLeftFileBtn) loadLeftFileBtn.addEventListener('click', () => handleLoadFile('left'));
        if (loadRightFileBtn) loadRightFileBtn.addEventListener('click', () => handleLoadFile('right'));

        // Semver utils (simple)
        function parseVersion(v){
            const m = (v||'').match(/(\d+)\.(\d+)\.(\d+)/); if(!m) return {major:0,minor:0,patch:0}; return {major:+m[1],minor:+m[2],patch:+m[3]};
        }
        function cmp(a,b){ if(a.major!==b.major) return a.major-b.major; if(a.minor!==b.minor) return a.minor-b.minor; return a.patch-b.patch; }
        function satisfies(v, range){
            // supports ">=x.y.z", "<x.y.z", chained by commas
            const ver=parseVersion(v);
            return (range||'').split(',').every(r=>{
                r=r.trim(); if(!r) return true; const op=r.slice(0,2).match(/[<>]=/) ? r.slice(0,2) : r[0];
                const num=r.replace(/[<>]=?|=\s*/g,'').trim(); const tgt=parseVersion(num);
                const c=cmp(ver,tgt);
                if(op==='>=') return c>=0; if(op==='<=') return c<=0; if(op==='>') return c>0; if(op==='<') return c<0; if(op==='=') return c===0; return true;
            });
        }

        function analyzeCompatibilityClick(){
            const leftCore = document.getElementById('leftCoreVersion').value.trim();
            const rightCore = document.getElementById('rightCoreVersion').value.trim();
            let leftReq={}, rightReq={};
            try{ leftReq = JSON.parse(document.getElementById('leftExtConstraints').value||'{}'); }catch(e){}
            try{ rightReq = JSON.parse(document.getElementById('rightExtConstraints').value||'{}'); }catch(e){}
            const used = (document.getElementById('usedPaths').value||'').split(',').map(s=>s.trim()).filter(Boolean);

            const hints=[]; let severity='green';
            // core range checks
            if(leftReq.lnbits && leftCore && !satisfies(leftCore,leftReq.lnbits)){ hints.push(`Left: core ${leftCore} not in required ${leftReq.lnbits}`); severity='red'; }
            if(rightReq.lnbits && rightCore && !satisfies(rightCore,rightReq.lnbits)){ hints.push(`Right: core ${rightCore} not in required ${rightReq.lnbits}`); severity='red'; }
            // extension deps summary
            const leftDeps = (leftReq.deps||{}); const rightDeps=(rightReq.deps||{});
            Object.keys(rightDeps).forEach(dep=>{ hints.push(`Right requires ${dep} ${rightDeps[dep]}`); });
            Object.keys(leftDeps).forEach(dep=>{ hints.push(`Left requires ${dep} ${leftDeps[dep]}`); });

            // API impact on used paths
            if(apiState.left && apiState.right){
                const {added,removed,changed} = computeDiff(apiState.left, apiState.right);
                const affects = (arr)=>arr.filter(k=> used.some(p=> k.includes(` ${p}`)) );
                const remA = affects(removed); const chA=affects(changed);
                if(remA.length){ hints.push(`Removed endpoints in used paths: ${remA.length}`); severity='red'; }
                if(chA.length){ hints.push(`Changed endpoints in used paths: ${chA.length}`); if(severity!=='red') severity='orange'; }
            }

            const verdictEl = document.getElementById('compatVerdict');
            const hintsEl = document.getElementById('compatHints');
            const color = severity==='red'?'#ff6b6b':(severity==='orange'?'#FFD166':'#4CAF50');
            verdictEl.style.color=color;
            verdictEl.textContent = severity==='green' ? 'Compatible' : (severity==='orange'?'Potentially risky':'Incompatible');
            hintsEl.innerHTML = hints.map(h=>`<li>${h}</li>`).join('');
        }

        const analyzeBtn = document.getElementById('analyzeCompatibility');
        if(analyzeBtn){ analyzeBtn.addEventListener('click', analyzeCompatibilityClick); }

        // Initialize on load
        window.addEventListener('load', function() {
            console.log('Window loaded, initializing...');
            // Only initialize if not already initialized
            if (!window.visualizationInitialized) {
                console.log('Initializing visualization...');
                initializeVisualization();
                initLegendToggle();
                setupGlobalClickHandler();
                initAnalysisButtons();
                window.visualizationInitialized = true;
                console.log('Initialization complete');
            } else {
                console.log('Already initialized');
            }
        });
        
        // Also try to initialize on DOMContentLoaded as backup
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, checking buttons...');
            setTimeout(() => {
                const exportBtn = document.getElementById('exportView');
                const printBtn = document.getElementById('printView');
                console.log('Button check:', {exportBtn: !!exportBtn, printBtn: !!printBtn});
                
                if (exportBtn && !exportBtn.onclick) {
                    console.log('Adding backup click handlers...');
                    exportBtn.onclick = () => {
                        console.log('Backup export click');
                        exportCurrentView();
                    };
                    printBtn.onclick = () => {
                        console.log('Backup print click');
                        printCurrentView();
                    };
                }
            }, 1000);
        });
        
        // Initialize analysis buttons
        function initAnalysisButtons() {
            console.log('Initializing analysis buttons...');
            
            // Export button
            const exportBtn = document.getElementById('exportView');
            if (exportBtn) {
                console.log('Found export button, adding listener');
                exportBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Export button clicked');
                    exportCurrentView();
                });
            } else {
                console.log('Export button not found');
            }
            
            // Print button
            const printBtn = document.getElementById('printView');
            if (printBtn) {
                console.log('Found print button, adding listener');
                printBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Print button clicked');
                    printCurrentView();
                });
            } else {
                console.log('Print button not found');
            }
            
            // Dependency modal controls
            const showAllDeps = document.getElementById('showAllDeps');
            const showCoreDeps = document.getElementById('showCoreDeps');
            const showExtDeps = document.getElementById('showExtDeps');
            
            if (showAllDeps) {
                showAllDeps.addEventListener('click', () => {
                    document.querySelectorAll('.dependency-btn').forEach(btn => btn.classList.remove('active'));
                    showAllDeps.classList.add('active');
                    renderDependencyAnalysis('all');
                });
            }
            
            if (showCoreDeps) {
                showCoreDeps.addEventListener('click', () => {
                    document.querySelectorAll('.dependency-btn').forEach(btn => btn.classList.remove('active'));
                    showCoreDeps.classList.add('active');
                    renderDependencyAnalysis('core');
                });
            }
            
            if (showExtDeps) {
                showExtDeps.addEventListener('click', () => {
                    document.querySelectorAll('.dependency-btn').forEach(btn => btn.classList.remove('active'));
                    showExtDeps.classList.add('active');
                    renderDependencyAnalysis('extension');
                });
            }
            
            // Close modal on outside click
            const modal = document.getElementById('dependencyModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeDependencyModal();
                    }
                });
            }
        }
        
        // Debounce resize events to prevent multiple renders
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                if (!window.isRendering && window.visualizationInitialized) {
                    const container = document.getElementById('schemaContainer');
                    const rect = container.getBoundingClientRect();
                    if (svg) {
                        svg.attr('width', rect.width).attr('height', rect.height);
                    }
                    renderSchema();
                    fitToContent(20);
                }
            }, 250);
        });

        function buildPairedRows(leftOnly, rightOnly, changedPairs, leftSpec, rightSpec, deprecated = []){
            console.log('buildPairedRows called with:', {
                leftOnly: leftOnly.length,
                rightOnly: rightOnly.length, 
                changedPairs: changedPairs.length,
                leftSpec: !!leftSpec,
                rightSpec: !!rightSpec
            });
            
            try {
            // Extract version info - core versions from spec info
            const leftVersion = leftSpec && leftSpec.info && leftSpec.info.version ? leftSpec.info.version : 'unknown';
            const rightVersion = rightSpec && rightSpec.info && rightSpec.info.version ? rightSpec.info.version : 'unknown';
            
            const ownerOf = (entry)=>{
                if (typeof entry !== 'string') return 'unknown';
                const m = entry.match(/^([A-Z]+)\s+([^<]+)/);
                const path = m ? m[2] : entry;
                const segs = path.split('/').filter(Boolean);
                if (!segs.length) return 'unknown';
                if (segs[0]==='api' || segs[0]==='public' || segs[0]==='users') return 'core';
                return segs[0];
            };
            
            // Group core endpoints by functionality
            const groupCoreEndpoints = (endpoints) => {
                const groups = {
                    'auth': [],
                    'payments': [],
                    'wallet': [],
                    'users': [],
                    'public': [],
                    'other': []
                };
                
                endpoints.forEach(endpoint => {
                    const path = endpoint.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || endpoint;
                    const lowerPath = path.toLowerCase();
                    
                    if (lowerPath.includes('/auth') || lowerPath.includes('/acl')) {
                        groups.auth.push(endpoint);
                    } else if (lowerPath.includes('/payment')) {
                        groups.payments.push(endpoint);
                    } else if (lowerPath.includes('/wallet')) {
                        groups.wallet.push(endpoint);
                    } else if (lowerPath.includes('/user')) {
                        groups.users.push(endpoint);
                    } else if (lowerPath.includes('/public')) {
                        groups.public.push(endpoint);
                    } else {
                        groups.other.push(endpoint);
                    }
                });
                
                return groups;
            };
            
            // Extract version info - core versions from spec info
            const leftCoreVersion = leftSpec && leftSpec.info && leftSpec.info.version ? leftSpec.info.version : 'unknown';
            const rightCoreVersion = rightSpec && rightSpec.info && rightSpec.info.version ? rightSpec.info.version : 'unknown';
            
            console.log(`Core versions - Left: ${leftCoreVersion}, Right: ${rightCoreVersion}`);
            
            // Get extension version from manifest info, fallback to tags-based extraction
            const getExtensionVersion = (spec, extensionName, targetSpec = null) => {
                console.log(`getExtensionVersion called with extensionName: "${extensionName}", spec:`, !!spec, 'targetSpec:', !!targetSpec);
                if (!extensionName || !spec) return 'unknown';
                
                // Use targetSpec if provided, otherwise fall back to rightSpec for backward compatibility
                const manifestSpec = targetSpec || rightSpec;
                
                console.log(`Getting version for ${extensionName}, spec has _manifestVersions:`, !!spec._manifestVersions);
                console.log(`Target spec has _manifestVersions:`, !!manifestSpec._manifestVersions);
                if (manifestSpec._manifestVersions) {
                    console.log(`Available manifest versions:`, Object.keys(manifestSpec._manifestVersions));
                    console.log(`Looking for key: "${extensionName.toLowerCase()}"`);
                    console.log(`Available keys:`, Object.keys(manifestSpec._manifestVersions));
                }
                
                // First try manifest info from target spec (most reliable)
                if (manifestSpec && manifestSpec._manifestVersions && manifestSpec._manifestVersions[extensionName.toLowerCase()]) {
                    const version = manifestSpec._manifestVersions[extensionName.toLowerCase()].version;
                    console.log(`Found manifest version for ${extensionName}: ${version}`);
                    return version;
                }
                
                // Then try manifest info on the spec itself
                if (spec._manifestVersions && spec._manifestVersions[extensionName.toLowerCase()]) {
                    const version = spec._manifestVersions[extensionName.toLowerCase()].version;
                    console.log(`Found spec manifest version for ${extensionName}: ${version}`);
                    return version;
                }
                
                // Then try manifest info on the spec itself (legacy)
                if (spec._manifestInfo && spec._manifestInfo.version) {
                    console.log(`Found manifest version for ${extensionName}: ${spec._manifestInfo.version}`);
                    return spec._manifestInfo.version;
                }
                
                // Fallback to attached _extVersions map
                const key = String(extensionName).toLowerCase();
                if (spec._extVersions && spec._extVersions[key]) {
                    console.log(`Found _extVersions for ${extensionName}: ${spec._extVersions[key]}`);
                    return spec._extVersions[key];
                }
                
                // Last resort: tags-based extraction
                if (!spec.tags) {
                    console.log(`No tags found for ${extensionName}`);
                    return 'unknown';
                }
                const tag = spec.tags.find(t => t.name && String(t.name).toLowerCase().includes(key));
                const result = tag && tag.description ? tag.description.match(/v?(\d+\.\d+\.\d+)/)?.[1] || 'unknown' : 'unknown';
                console.log(`Tags-based version for ${extensionName}: ${result}`);
                return result;
            };
            
            // Create a map of normalized paths to track all variations
            const pathMap = new Map();
            
            // Process changed pairs - these are the same endpoint with differences
            changedPairs.forEach(p=>{
                const leftPath = p.left.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || p.left;
                const rightPath = p.right.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || p.right;
                const leftMethod = p.left.match(/^([A-Z]+)\s/)?.[1] || '';
                const rightMethod = p.right.match(/^([A-Z]+)\s/)?.[1] || '';
                
                const key = leftPath; // use left path as base
                pathMap.set(key, {
                    owner: ownerOf(p.left),
                    left: p.left,
                    right: p.right,
                    changes: (p.details||[]).join('; '),
                    leftMethod,
                    rightMethod,
                    leftPath,
                    rightPath
                });
            });
            
            // Smart endpoint matching - detect similar endpoints that should be compared
            const smartMatches = [];
            leftOnly.forEach(leftEndpoint => {
                const leftPath = leftEndpoint.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || leftEndpoint;
                const leftMethod = leftEndpoint.match(/^([A-Z]+)\s/)?.[1] || '';
                
                // Find similar right endpoint
                const similarRight = rightOnly.find(rightEndpoint => {
                    const rightPath = rightEndpoint.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || rightEndpoint;
                    const rightMethod = rightEndpoint.match(/^([A-Z]+)\s/)?.[1] || '';
                    
                    // Same method and similar path structure
                    if (leftMethod !== rightMethod) return false;
                    
                    // Extract path segments
                    const leftSegs = leftPath.split('/').filter(Boolean);
                    const rightSegs = rightPath.split('/').filter(Boolean);
                    
                    // Same number of segments and same structure (ignoring parameter names)
                    if (leftSegs.length !== rightSegs.length) return false;
                    
                    // Check if segments match (ignoring parameter names)
                    for (let i = 0; i < leftSegs.length; i++) {
                        const leftSeg = leftSegs[i].replace(/^\{.*\}$/, '{}');
                        const rightSeg = rightSegs[i].replace(/^\{.*\}$/, '{}');
                        if (leftSeg !== rightSeg) return false;
                    }
                    
                    return true;
                });
                
                if (similarRight) {
                    const rightPath = similarRight.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || similarRight;
                    
                    // Analyze the specific changes
                    const leftSegs = leftPath.split('/').filter(Boolean);
                    const rightSegs = rightPath.split('/').filter(Boolean);
                    const changes = [];
                    
                    for (let i = 0; i < leftSegs.length; i++) {
                        const leftSeg = leftSegs[i];
                        const rightSeg = rightSegs[i];
                        
                        if (leftSeg !== rightSeg && leftSeg.startsWith('{') && rightSeg.startsWith('{')) {
                            // Parameter name changed
                            changes.push(`param: ${leftSeg.slice(1, -1)} → ${rightSeg.slice(1, -1)}`);
                        }
                    }
                    
                    smartMatches.push({
                        left: leftEndpoint,
                        right: similarRight,
                        leftPath,
                        rightPath,
                        changes: changes.length > 0 ? changes.join('; ') : 'path parameters changed'
                    });
                }
            });
            
            // Add smart matches to pathMap
            smartMatches.forEach(match => {
                const key = match.leftPath;
                pathMap.set(key, {
                    owner: ownerOf(match.left),
                    left: match.left,
                    right: match.right,
                    changes: match.changes,
                    leftMethod: match.left.match(/^([A-Z]+)\s/)?.[1] || '',
                    rightMethod: match.right.match(/^([A-Z]+)\s/)?.[1] || '',
                    leftPath: match.leftPath,
                    rightPath: match.rightPath
                });
            });
            
            // Process left-only (removed from right) - exclude smart matches
            leftOnly.forEach(l=>{
                const path = l.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || l;
                if (!pathMap.has(path)) {
                    // Check if this endpoint is deprecated (including parent paths)
                    const isDeprecated = deprecated.some(dep => {
                        const depPath = dep.replace(/^[A-Z]+\s+/, ''); // Remove method prefix
                        // Check if this path starts with any deprecated path
                        return path.startsWith(depPath) || depPath.startsWith(path);
                    });
                    pathMap.set(path, {
                        owner: ownerOf(l),
                        left: l,
                        right: '',
                        changes: isDeprecated ? 'deprecated' : 'removed',
                        leftMethod: l.match(/^([A-Z]+)\s/)?.[1] || '',
                        rightMethod: '',
                        leftPath: path,
                        rightPath: ''
                    });
                }
            });
            
            // Process right-only (added to right)
            rightOnly.forEach(r=>{
                const path = r.match(/^([A-Z]+)\s+([^<]+)/)?.[2] || r;
                if (!pathMap.has(path)) {
                    pathMap.set(path, {
                        owner: ownerOf(r),
                        left: '',
                        right: r,
                        changes: 'added',
                        leftMethod: '',
                        rightMethod: r.match(/^([A-Z]+)\s/)?.[1] || '',
                        leftPath: '',
                        rightPath: path
                    });
                }
            });
            
            // Group by owner
            const groups = {};
            pathMap.forEach((data, path) => {
                const owner = data.owner;
                if (!groups[owner]) groups[owner] = [];
                groups[owner].push(data);
            });
            
            // Don't filter out extensions - show all extensions that have any endpoints
            // Extensions might have different endpoint sets on left vs right
            
            // Build HTML
            const groupOrder = Object.keys(groups).sort((a,b)=> a==='core'?-1:(b==='core'?1:a.localeCompare(b)));
            let html = '';
            groupOrder.forEach(g=>{
                if (g === 'core') {
                    // Special handling for core - group by functionality
                    const coreData = groups[g];
                    const coreGroups = groupCoreEndpoints(coreData.map(d => d.left || d.right).filter(Boolean));
                    
                    Object.keys(coreGroups).forEach(subGroup => {
                        if (coreGroups[subGroup].length === 0) return;
                        
                        const subGroupData = coreData.filter(d => {
                            const path = (d.left || d.right).match(/^([A-Z]+)\s+([^<]+)/)?.[2] || '';
                            const lowerPath = path.toLowerCase();
                            
                            if (subGroup === 'auth') return lowerPath.includes('/auth') || lowerPath.includes('/acl');
                            if (subGroup === 'payments') return lowerPath.includes('/payment');
                            if (subGroup === 'wallet') return lowerPath.includes('/wallet');
                            if (subGroup === 'users') return lowerPath.includes('/user');
                            if (subGroup === 'public') return lowerPath.includes('/public');
                            return subGroup === 'other';
                        });
                        
                        if (subGroupData.length === 0) return;
                        
                        const subGroupTitle = subGroup.charAt(0).toUpperCase() + subGroup.slice(1);
                        
                        // Analyze changes in this group to generate bubbles
                        const changeTypes = new Set();
                        subGroupData.forEach(data => {
                            if (data.changes === 'removed') changeTypes.add('removed');
                            else if (data.changes === 'added') changeTypes.add('added');
                            else if (data.changes === 'deprecated') changeTypes.add('deprecated');
                            else if (data.changes) changeTypes.add('changed');
                        });
                        
                        let bubbles = '';
                        if (changeTypes.has('added')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#51cf66;margin-left:8px;" title="Added"></span>';
                        if (changeTypes.has('removed')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#ff6b6b;margin-left:8px;" title="Removed"></span>';
                        if (changeTypes.has('changed')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#ffa500;margin-left:8px;" title="Changed"></span>';
                        if (changeTypes.has('deprecated')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#9c27b0;margin-left:8px;" title="Deprecated"></span>';
                        
                        html += `<div class="paired-group collapsed" style="padding:6px 8px; margin-top:12px;">Core: ${subGroupTitle}${bubbles}</div>`;
                        html += `<table class="paired-table"><colgroup><col style=\"width:45%\"/><col style=\"width:45%\"/><col style=\"width:10%\"/></colgroup><thead><tr><th>v${leftVersion}</th><th>v${rightVersion}</th><th>Change</th></tr></thead><tbody>`;
                        
                        subGroupData.forEach(data=>{
                            // Extract just the method and path, remove "Left" and "Right" prefixes
                            let left = data.left ? data.left.replace(/^(Left|Right)\s+/, '') : '<span style="color:#555">—</span>';
                            let right = data.right ? data.right.replace(/^(Left|Right)\s+/, '') : '<span style="color:#555">—</span>';
                            let change = '';
                            
                            if (data.changes === 'removed') {
                                // Check if this is actually "not installed" vs "removed"
                                const isExtension = data.left && data.left.includes('/api/v1/');
                                const leftVersion = getExtensionVersion(leftSpec, data.left, leftSpec);
                                const rightVersion = getExtensionVersion(rightSpec, data.right, rightSpec);
                                
                                if (isExtension && leftVersion === 'unknown' && rightVersion !== 'unknown') {
                                    change = '<span style="color:#ffa500">(not installed)</span>';
                                } else {
                                    change = '<span style="color:#ff6b6b">(removed)</span>';
                                }
                            } else if (data.changes === 'added') {
                                change = '<span style="color:#51cf66">(added)</span>';
                            } else if (data.changes === 'deprecated') {
                                change = '<span style="color:#9c27b0">(deprecated)</span>';
                            } else if (data.changes) {
                                // Parse specific changes
                                const changes = data.changes.split('; ');
                                const changeParts = [];
                                
                                if (data.leftMethod !== data.rightMethod) {
                                    changeParts.push(`method changed: ${data.leftMethod} → ${data.rightMethod}`);
                                }
                                
                                changes.forEach(c => {
                                    if (c.includes('path params:')) {
                                        changeParts.push(c);
                                    } else if (c.includes('operationId')) {
                                        changeParts.push('operationId changed');
                                    } else if (c.includes('parameters')) {
                                        changeParts.push('parameters changed');
                                    } else if (c.includes('responses')) {
                                        changeParts.push('responses changed');
                                    }
                                });
                                
                                change = changeParts.length > 0 ? 
                                    `<span class="diff-changed">${changeParts.join('; ')}</span>` : 
                                    '<span class="diff-changed">modified</span>';
                            }
                            
                            html += `<tr><td>${left}</td><td>${right}</td><td>${change}</td></tr>`;
                        });
                        
                        html += `</tbody></table>`;
                    });
                } else {
                    // Extension handling (unchanged)
                    const title = `Extension: ${g}`;
                    const isCollapsed = 'collapsed';
                    
                    // Get extension-specific versions if available
                    let leftExtVersion = leftVersion;
                    let rightExtVersion = rightVersion;
                    leftExtVersion = getExtensionVersion(leftSpec, g, leftSpec);
                    rightExtVersion = getExtensionVersion(rightSpec, g, rightSpec);
                    
                    // If we don't know the extension version, show "unknown" instead of core version
                    if (leftExtVersion === 'unknown') {
                        leftExtVersion = 'unknown';
                    }
                    if (rightExtVersion === 'unknown') {
                        rightExtVersion = 'unknown';
                    }
                    
                    // Analyze changes in this extension to generate bubbles
                    const changeTypes = new Set();
                    groups[g].forEach(data => {
                        if (data.changes === 'removed') changeTypes.add('removed');
                        else if (data.changes === 'added') changeTypes.add('added');
                        else if (data.changes === 'deprecated') changeTypes.add('deprecated');
                        else if (data.changes) changeTypes.add('changed');
                    });
                    
                    let bubbles = '';
                    if (changeTypes.has('added')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#51cf66;margin-left:8px;" title="Added"></span>';
                    if (changeTypes.has('removed')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#ff6b6b;margin-left:8px;" title="Removed"></span>';
                    if (changeTypes.has('changed')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#ffa500;margin-left:8px;" title="Changed"></span>';
                    if (changeTypes.has('deprecated')) bubbles += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#9c27b0;margin-left:8px;" title="Deprecated"></span>';
                    
                    html += `<div class="paired-group ${isCollapsed}" style="padding:6px 8px; margin-top:12px;">${title}${bubbles}</div>`;
                    html += `<table class="paired-table"><colgroup><col style=\"width:45%\"/><col style=\"width:45%\"/><col style=\"width:10%\"/></colgroup><thead><tr><th>v${leftExtVersion}</th><th>v${rightExtVersion}</th><th>Change</th></tr></thead><tbody>`;
                    
                    groups[g].forEach(data=>{
                        // Extract just the method and path, remove "Left" and "Right" prefixes
                        let left = data.left ? data.left.replace(/^(Left|Right)\s+/, '') : '<span style="color:#555">—</span>';
                        let right = data.right ? data.right.replace(/^(Left|Right)\s+/, '') : '<span style="color:#555">—</span>';
                        let change = '';
                        
                        if (data.changes === 'removed') {
                            // Check if this is actually "not installed" vs "removed"
                            const isExtension = data.left && data.left.includes('/api/v1/');
                            const leftVersion = getExtensionVersion(leftSpec, data.left, leftSpec);
                            const rightVersion = getExtensionVersion(rightSpec, data.right, rightSpec);
                            
                            if (isExtension && leftVersion === 'unknown' && rightVersion !== 'unknown') {
                                change = '<span style="color:#ffa500">(not installed)</span>';
                            } else {
                                change = '<span style="color:#ff6b6b">(removed)</span>';
                            }
                        } else if (data.changes === 'added') {
                            change = '<span style="color:#51cf66">(added)</span>';
                        } else if (data.changes === 'deprecated') {
                            change = '<span style="color:#9c27b0">(deprecated)</span>';
                        } else if (data.changes) {
                            // Parse specific changes
                            const changes = data.changes.split('; ');
                            const changeParts = [];
                            
                            if (data.leftMethod !== data.rightMethod) {
                                changeParts.push(`method changed: ${data.leftMethod} → ${data.rightMethod}`);
                            }
                            
                            changes.forEach(c => {
                                if (c.includes('path params:')) {
                                    changeParts.push(c);
                                } else if (c.includes('operationId')) {
                                    changeParts.push('operationId changed');
                                } else if (c.includes('parameters')) {
                                    changeParts.push('parameters changed');
                                } else if (c.includes('responses')) {
                                    changeParts.push('responses changed');
                                }
                            });
                            
                            change = changeParts.length > 0 ? 
                                `<span class="diff-changed">${changeParts.join('; ')}</span>` : 
                                '<span class="diff-changed">modified</span>';
                        }
                        
                        html += `<tr><td>${left}</td><td>${right}</td><td>${change}</td></tr>`;
                    });
                    
                    html += `</tbody></table>`;
                }
            });
            return html;
            } catch (e) {
                console.error('buildPairedRows internal error:', e);
                console.error('Error stack:', e.stack);
                return '<p>Error building comparison table: ' + e.message + '</p>';
            }
        }
    </script>
</body>
</html>

